#!/bin/bash
# Bash script to run a milestone build providing the version number.

prog_name="$0"
amboso_currvers="1.3.1"
amboso_testflag_version="1.3.0"
amboso_version="amboso version $amboso_currvers"

function echo_amboso_version {
  echo "$amboso_version"
}
function echo_amboso_version_short {
  echo "$amboso_currvers"
}

function set_supported_versions {
  dir=$1
  [[ ! -f $dir/stego.lock ]] && echo -e "\033[1;31m[ERROR]    Can't find \"stego.lock\" in ( $dir ).\e[0m\n" && exit 1
  git_tags_count=0
  base_tags_count=0
  j=0
  k=0
  i=0

  while IFS= read -r line; do {
    #Skip the first five lines, reserved for header, source file and target executable names, test folder, and versions header
    [[ $j -lt 6 ]] && j=$((j+1)) && continue

    was_git_tag=0
    was_base_tag=0
    for tag in $(echo "$line" | grep -v '^?' | cut -d '#' -f 1 | cut -d ' ' -f 1 | grep -v '^$'); do {
      read_git_mode_tags[git_tags_count]="$tag"
      git_tags_count=$(($git_tags_count+1))
      was_git_tag=1
    }
    done
    for tag in $(echo "$line" | grep '^?'| cut -d '?' -f2 | cut -d '#' -f 1 | cut -d ' ' -f1 | grep -v '^$'); do {
      read_base_mode_tags[base_tags_count]="$tag"
      base_tags_count=$(($base_tags_count+1))
      was_base_tag=1
    }
    done

    #echo "Text read from file: ( $line )"
    #echo "Text read from file, no comments: ( $( echo "$line" | cut -d '#' -f 1 ) )"
    if [[ $base_mode_flag -gt 0 && $was_base_tag -gt 0 ]] ; then {
      read_versions[k]=${read_base_mode_tags[$k]}
      k=$((k+1))
    } elif [[ $git_mode_flag -gt 0 && $was_git_tag -gt 0 ]] ; then {
      read_versions[k]=${read_git_mode_tags[$k]}
      k=$((k+1))
    }
    fi
  }
  done < "$dir/stego.lock" 2>/dev/null
  #echo "version array size is " "${#read_versions[@]}" >&2
  count_git_versions="${#read_git_mode_tags[@]}"
  count_base_versions="${#read_base_mode_tags[@]}"
  #echo "$count_versions"
  #echo "version array contents are: ( ${read_versions[@]} )" >&2
  if [[ $base_mode_flag -gt 0 ]] ; then {
    for i in $(seq 0 $(($count_base_versions-1))); do
      supported_versions[i]=${read_base_mode_tags[$i]}
    done
  } else {
    for i in $(seq 0 $(($count_git_versions-1))); do
      supported_versions[i]=${read_git_mode_tags[$i]}
    done
  }
  fi

  tot_vers=${#supported_versions[@]}
}

function set_source_info {
  dir=$1
  [[ ! -f $dir/stego.lock ]] && echo -e "\033[1;31m[ERROR]    Can't find \"stego.lock\" in ( $dir ). Try running with -D to specify the right directory.\e[0m\n" && exit 1
  j=0
  k=0
  while IFS= read -r line; do
    #Skip the first line header
    [[ $j -lt 1 ]] && j=$((j+1)) && continue

    #echo "Text read from file: ( $line )"
    #echo "Text read from file, no comments: ( $( echo "$line" | cut -d '#' -f 1 ) )"
    sources_info[k]=$(echo "$line" | cut -d '#' -f 1 | cut -d ' ' -f 1 )
    k=$((k+1))
    [[ $k -eq 4 ]] && break #we only read the first three lines
  done < "$dir/stego.lock" 2>/dev/null
  #echo "source info array size is " "${#sources_info[@]}" >&2
  count_source_infos="${#sources_info[@]}"
  #echo "$count_source_infos"
  #echo "source info array contents are: ( ${sources_info[@]} )" >&2
}

function set_tests_info {
  dir="$1"
  [[ ! -f "$dir"/kazoj.lock ]] && echo -e "\033[1;31m[ERROR]    Can't find \"kazoj.lock\" in ( $dir ). Try running with -K to specify the right directory.\e[0m\n" && exit 1
  j=0
  k=0
  while IFS="\n" read -r line; do
    #Skip the first and third line header
    [[ $j -lt 1 || $j -eq 2 ]] && j=$((j+1)) && continue
    #echo "Text read from file: ( $line )"
    #echo "Text read from file, no comments: ( $( echo "$line" | cut -d '#' -f 1 ) )"
    tests_info[k]=$(echo "$line" | cut -d '#' -f 1 | cut -d ' ' -f 1 )
    k=$((k+1))
    j=$((j+1))
    [[ $k -lt 2 ]] || break #we only read two values
  done < "$dir/kazoj.lock" 2>/dev/null
  #echo "test info array size is " "${#tests_info[@]}" >&2
  count_tests_infos="${#tests_info[@]}"
  #echo "$count_tests_infos"
  #echo "test info array contents are: ( ${tests_info[@]} )" >&2
}

function set_supported_tests {
  kazoj_dir=$1
  set_tests_info "$1"
  cases_dir="${tests_info[0]}"
  errors_dir="${tests_info[1]}"
  tests_filecount=0
  errors_filecount=0
  skipped=0
  i=0

  #tests loop
  cases_path="$kazoj_dir/$cases_dir"
  errorcases_path="$kazoj_dir/$errors_dir"
  for FILE in $(ls "$cases_path"); do {
    test_fp="$cases_path/$FILE"
    if ! [[ -f $test_fp && -x $test_fp ]] ; then {
      skipped=$((skipped+1))
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[TEST]    Skip test $FILE (at $test_fp), not an executable file.\e[0m" >&2
      continue
    }
    fi
    read_tests_files["$tests_filecount"]="$FILE"
    tests_filecount=$(($tests_filecount+1))
  }
  done
  #errors loop
  for FILE in $(ls "$errorcases_path"); do {
    test_fp="$errorcases_path/$FILE"
    if ! [[ -f $test_fp && -x $test_fp ]] ; then {
      skipped=$((skipped+1))
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[TEST]    Skip errtest $FILE (at $test_fp), not an executable file.\e[0m" >&2
      continue
    }
    fi
    read_errortests_files["$errors_filecount"]="$FILE"
    errors_filecount=$(($errors_filecount+1))
  }
  done
  #echo "version array size is " "${#read_versions[@]}" >&2
  count_tests_names="${#read_tests_files[@]}"
  count_errortests_names="${#read_errortests_files[@]}"
  for i in $(seq 0 $(($count_tests_names-1))); do
    supported_tests[i]=${read_tests_files[$i]}
  done
  for i in $(seq 0 $(($count_errortests_names-1))); do
    supported_tests[$(($i + $count_tests_names))]=${read_errortests_files[$i]}
  done
  tot_tests=${#supported_tests[@]}
  #echo "tot tests: $tot_tests"
}

function echo_tests_info {
  kazoj_dir="$1"
  set_supported_tests "$kazoj_dir" 2>/dev/null
  echoed_cases_dir="${tests_info[0]}"
  echoed_errors_dir="${tests_info[1]}"
  echo -e "\033[1;33m[DEBUG]    Tests dir is: ( $kazoj_dir ).\e[0m" >&2
  echo -e "\033[1;33m[DEBUG]    Cases dir is: ( $echoed_cases_dir ).\e[0m" >&2
  echo -e "\033[1;33m[DEBUG]      ( $count_tests_names ) cases ready.\e[0m" >&2
  if [[ $big_list_flag -gt 0 ]] ; then {
    for i in $(seq 0 $(($count_tests_names-1))) ; do {
      echo -e "\033[1;33m[DEBUG]      ( ${read_tests_files[$i]} ).\e[0m" >&2
    }
    done
  }
  fi
  echo -e "\033[1;33m[DEBUG]    Errors dir is: ( $echoed_errors_dir ).\e[0m" >&2
  echo -e "\033[1;33m[DEBUG]      ( $count_errortests_names ) error cases ready.\e[0m" >&2
  if [[ $big_list_flag -gt 0 ]] ; then {
    for i in $(seq 0 $(($count_errortests_names-1))) ; do {
      echo -e "\033[1;33m[DEBUG]      ( ${read_errortests_files[$i]} ).\e[0m" >&2
    }
    done
  }
  fi
  echo -e "\033[1;33m[DEBUG]    ( $tot_tests ) total tests ready.\e[0m" >&2
  #echo "$count_tests_infos"
  #echo "test info array contents are: ( ${tests_info[@]} )" >&2
}

function echo_othermode_tags {
  dir="$1"
  set_supported_versions "$dir"

  #Print remaining read versions not available in current mode
  if [[ $base_mode_flag -gt 0 ]] ; then {
    mode_txt="\033[1;34mgit\e[0m"
    echo -e "  ( $count_git_versions ) supported tags when running in ( $mode_txt ) mode."
    echo -e "  Run again in ( $mode_txt ) mode to use them."
    for i in $(seq 0 $(($count_git_versions-1))); do {
      (( $i % 4 == 0)) && [[ $i -ne 0 ]] && echo -en "\n"
      echo -en "    \033[0;33m${read_git_mode_tags[i]}\e[0m"
    }
    done
  } else {
    mode_txt="\033[1;31mbase\e[0m"
    echo -e "  ( $count_base_versions ) supported tags when running in ( $mode_txt ) mode."
    echo -e "  Run again in ( $mode_txt ) mode to use them."
    for i in $(seq 0 $(($count_base_versions-1))); do {
      (( $i % 4 == 0)) && [[ $i -ne 0 ]] && echo -en "\n"
      echo -en "    \033[0;33m${read_base_mode_tags[i]}\e[0m"
    }
    done
  }
  fi
  echo "" >&2
}

function echo_supported_tags {
  mode_txt="\033[1;34mgit\e[0m"
  [[ $base_mode_flag -gt 0 ]] && mode_txt="\033[1;31mbase\e[0m"
  dir="$1"
  set_supported_versions "$dir"
  echo -e "  ( $tot_vers ) supported tags for current mode ( $mode_txt )."
  for i in $(seq 0 $(($tot_vers-1))); do { #Print currently supported versions (only ones conforming to mode)
    (( $i % 4 == 0)) && [[ $i -ne 0 ]] && echo -en "\n"
    echo -en "    \033[1;32m${supported_versions[i]}\e[0m"
  }
  done
  echo "" >&2
}

function echo_options {
  echo -e "\n    [RUNMODES]:\n"
  echo -e "        -B        base mode\n"
  echo -e "                Uses full source builds. Not recommended.\n"
  echo -e "        -g        git mode\n"
  echo -e "                Uses git checkouts of supported tags. Enabled by default.\n"
  echo -e "        -t        test mode\n"
  echo -e "                Tries all defined tests.\n"
  echo -e "    [OPERATIONS]:\n"
  echo -e "        -T        test mode\n"
  echo -e "                Tries the queried test.\n"
  echo -e "        -b        build\n"
  echo -e "                Tries building the binary if it's not available.\n"
  echo -e "        -r        run\n"
  echo -e "                Specifies you want to run the tag.\n"
  echo -e "        -d        delete\n"
  echo -e "                Deletes queried tag binary and quits.\n"
  echo -e "        -i        init\n"
  echo -e "                Tries building all supported versions.\n"
  echo -e "        -p        purge\n"
  echo -e "                Removes all tags binaries and quits.\n"
  echo -e "    [OPTIONS]:\n"
  echo -e "        -D TARGET_DIR        directory\n"
  echo -e "                Specifies target directory\n"
  echo -e "        -E TARGET_EXEC       executable\n"
  echo -e "                Specifies target executable name\n"
  echo -e "        -S TARGET_SOURCE       sourcename\n"
  echo -e "                Specifies sourcefile name for single file mode.\n"
  echo -e "        -M MAKEFILE_SUPPORT       tagname\n"
  echo -e "                Specifies a tag name for lowest version to support make.\n"
  echo -e "        -K TEST_FOLDER       path\n"
  echo -e "                Specifies a relative dirname for test folder.\n"
  echo -e "    [INFO]:\n"
  echo -e "        -l/L        list\n"
  echo -e "                Prints supported tags for current mode (all modes if L) and quits.\n"
  echo -e "        -q        quiet\n"
  echo -e "                Less debug output, recursive.\n"
  echo -e "        -V        verbose\n"
  echo -e "                More debug output.\n"
  echo -e "        -h/H        help\n"
  echo -e "                Prints help info (paged if -h) and quits.\n"
  echo -e "        -v        version\n"
  echo -e "                Prints version message and quits.\n"
}

function git_mode_check {
  is_git_repo=0
  #Check if we're inside a repo
  git rev-parse --is-inside-work-tree 2>/dev/null 1>&2
  is_git_repo="$?"
  [[ $is_git_repo -gt 0 ]] && echo -e "\n\033[1;31m[ERROR]    Not running in a git repo. Try running with -B to use base mode.\e[0m\n" && exit 1
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;34m[AMBOSO-MODE]    Running in git mode.\e[0m" >&2
}

function usage {
  echo -e "Usage: $(basename $prog_name) [OPTION]... VERSION_QUERY\n"
  echo "    Query for a build version"
  #echo_supported_tags "$milestones_dir"
  #echo ""
  #echo_othermode_tags "$milestones_dir"
  echo_options
}

function escape_colorcodes_tee {
  file="$1"
  outfile="$2"
  echo "" >"$outfile"
  #sed -r 's/\/\\3/g' "$file"
  #sed -e 's/\\033\[/COLOR[/g' -e 's/COLOR\[1;3/"<colorTag[Heavy,/g' -e 's/COLOR\[0;3/"<colorTag[Light,/g' -e 's/\\e\[0m/\]>"/g' "$file" >>"$outfile"
  #sed 's/\x1B\[\([0-9]\{1,2\}\(;[0-9]\{1,2\}\)\?\)\?[mGK]//g' <"$file"
  cat -e "$file" | tee "$outfile"
}

function escape_colorcodes {
  file="$1"
  outfile="$2"
  echo "" >"$outfile"
  #sed -r 's/\/\\3/g' "$file"
  #sed -e 's/\\033\[/COLOR[/g' -e 's/COLOR\[1;3/"<colorTag[Heavy,/g' -e 's/COLOR\[0;3/"<colorTag[Light,/g' -e 's/\\e\[0m/\]>"/g' "$file" >>"$outfile"
  #sed 's/\x1B\[\([0-9]\{1,2\}\(;[0-9]\{1,2\}\)\?\)\?[mGK]//g' <"$file"
  cat -e "$file" >"$outfile"
}

function record_test {
  tfp="$1" # test_file_path
  echo "" > "$tfp.stdout"
  echo "" > "$tfp.stderr"
  tmp_stdout="$(mktemp)"
  tmp_stderr="$(mktemp)"
  run_test "$tfp" >>"$tmp_stdout" 2>>"$tmp_stderr"
  res="$?"
  echo "r: $res" >> "$tmp_stdout"
  escape_colorcodes_tee "$tmp_stdout" "$tfp.stdout"
  escape_colorcodes_tee "$tmp_stderr" "$tfp.stderr"
  rm -f "$tmp_stdout" || echo "\033[1;31m[ERROR]    Failed removing tmpfile ($tmp_stdout). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$tmp_stdout".\e[0m" >&2
  rm -f "$tmp_stderr" || echo "\033[1;31m[ERROR]    Failed removing tmpfile ($tmp_stderr). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$tmp_stderr".\e[0m" >&2
}

function run_test {
  tfp="$1" # test_file_path
  #echo -en "\033[1;36m"
  "$tfp"
  #echo -en "\e[0m"
  res=$?
}

function delete_test {
  tfp="$1" # test_file_path
  (
    echo "deleting $tfp" 2>/dev/null
    exit "$?"
  )
  res="$?"

  if [[ $res -eq 0 ]]; then {
    echo -e "\033[0;32m[TEST]    Deleted $tfp.\e[0m" >&2
  } else {
    echo -e "\033[1;31m[TEST]    Failed deleting $tfp. How?\e[0m" >&2
  }
  fi
}

#Prepare flag values to default value
purge_flag=0
run_flag=0 #By default we don't run the binary
build_flag=0
delete_flag=0
init_flag=0
verbose_flag=0
quiet_flag=0
dir_flag=0
exec_entrypoint= #By default the value is empty
exec_was_set=0
source_name=
sourcename_was_set=0
bighelp_flag=0
smallhelp_flag=0
vers_make_flag=0
makefile_version=""
git_mode_flag=1 #By default we run in git mode
base_mode_flag=0
test_mode_flag=0
big_test_mode_flag=0
test_info_was_set=0
testdir_flag=0
kazoj_dir=""
big_list_flag=0
small_list_flag=0
version_flag=0

while getopts "M:S:E:D:K:BgVbpHhrivdlLtTq" opt; do
  case $opt in
    S )
      source_name="$OPTARG"
      sourcename_was_set=1
      ;;
    E )
      exec_entrypoint="$OPTARG"
      exec_was_set=1
      ;;
    D )
      dir_flag=1
      milestones_dir="$OPTARG"
      ;;
    K )
      testdir_flag=1
      kazoj_dir="$OPTARG"
      test_info_was_set=1
      ;;
    M )
      vers_make_flag=1
      makefile_version="$OPTARG"
      ;;
    L )
      big_list_flag=1
      ;;
    l )
      small_list_flag=1
      ;;
    H )
      bighelp_flag=1
      ;;
    h )
      smallhelp_flag=1
      ;;
    B )
      base_mode_flag=1
      ;;
    g )
      git_mode_flag=1
      ;;
    t )
      test_mode_flag=1
      ;;
    T )
      big_test_mode_flag=1
      ;;
    V )
      verbose_flag=1
      ;;
    q )
      quiet_flag=1
      ;;
    v )
      version_flag=$(($version_flag+1))
      ;;
    p )
      purge_flag=1
      ;;
    r )
      run_flag=1
      ;;
    b )
      build_flag=1
      ;;
    d )
      delete_flag=1
      ;;
    i )
      init_flag=1
      ;;
    \? )
      echo "Invalid option: -$OPTARG. Run with -h for help." >&2
      exit 1
      ;;
    : )
      echo "Option -$OPTARG requires an argument. Run with -h for help." >&2
      exit 1
      ;;
  esac
tot_opts=$OPTIND
done

if [[ $version_flag -gt 1 ]] ; then {
  echo_amboso_version_short
  exit 0
} elif [[ $version_flag -eq 1 ]] ; then {
  echo_amboso_version
  exit 0
}
fi

#We check again if testmode was requested, and reset the other mode flags.
if [[ $test_mode_flag -gt 0 ]] ; then {
  git_mode_flag=0
  base_mode_flag=0
  echo -e "\033[1;33m[AMBOSO-MODE]    Running in test mode.\e[0m" >&2
}
fi

#We check again if basemode was requested, as the only flag checked in build stage is git_mode_flag
#If base_mode_flag is asserted, we always override git_mode_flag
[[ $base_mode_flag -gt 0 ]] && git_mode_flag=0 && echo -e "\033[1;31m[AMBOSO-MODE]    Running in base mode, expecting full source builds.\e[0m" >&2
[[ $git_mode_flag -gt 0 ]] && git_mode_check #We are now sure we can quit immediately if not running in a git repo

#We always notify of missing -D argument
[[ ! $dir_flag -gt 0 ]] && milestones_dir="$(pwd)/bin/" && echo -e "\033[1;33m[DEBUG]    No -D flag, using ( $milestones_dir ) for target dir. Run with -V to see more.\e[0m" >&2 #&& usage && exit 1

#We always notify of missing -K argument, if in test mode
if [[ $test_mode_flag -gt 0 && ! $testdir_flag -gt 0 ]] ; then {
  set_source_info "$milestones_dir"
  kazoj_dir="${sources_info[3]}"
  set_tests_info "$kazoj_dir"
  set_supported_tests "$kazoj_dir"
  #kazoj_dir="$(pwd)/kazoj/"
  echo -e "\033[1;33m[DEBUG]    No -K flag, using ( $kazoj_dir ) for target dir. Run with -V to see more.\e[0m" >&2 #&& usage && exit 1
}
fi

#Check if we are printing help info and exiting early
if [[ $smallhelp_flag -gt 0 ]]; then {
      "$prog_name" -H -D "$milestones_dir" | less
      exit 0
}
fi
#Check if we are printing Help info and exiting early
if [[ $bighelp_flag -gt 0 ]]; then {
      echo_amboso_version
      set_source_info "$milestones_dir"
      set_supported_versions "$milestones_dir"
      set_supported_versions "$milestones_dir"
      usage
      exit 0
}
fi

scripts_dir="$milestones_dir" # MUST BE SET before checking for -S and -E
set_supported_versions "$scripts_dir" # Might as well do it now
set_source_info "$milestones_dir"
kazoj_dir="${sources_info[3]}"
set_tests_info "$kazoj_dir"
set_supported_tests "$kazoj_dir"

#If we're in test mode and test dir was not passed, we check if "./kazoj" is a directory and use that. If it isn't, we may get the name from stego.lock. If that is not a directory, we quit immediately.
if [[ -z $kazoj_dir && $test_mode_flag -gt 0 ]] ; then {
  if [[ "$amboso_currvers" > "$amboso_testflag_version" || "$amboso_currvers" = "$amboso_testflag_version" ]] ; then {
     if [[ -d "./kazoj" ]]; then {
       kazoj_dir="./kazoj"
       set_tests_info "$kazoj_dir"
       set_supported_tests "$kazoj_dir"
       echo -e "\033[1;33m[DEBUG]    No -K flag on a test run (amboso > $amboso_testflag_version), using \"./kazoj\" as tests dir.\e[0m" >&2
     } else {
       echo -e "\033[1;33m[DEBUG]    No -K flag on a test run (amboso > $amboso_testflag_version), reading stego.lock.\e[0m" >&2
       set_source_info "$milestones_dir"
       kazoj_dir="${sources_info[3]}"
       set_tests_info "$kazoj_dir"
       set_supported_tests "$kazoj_dir"
     }
     fi
  } else {
     echo -e "\033[1;31m[ERROR]    No -K flag on a test run, amboso version is < ($amboso_testflag_version).\n    Quitting.\e[0m" #>&2
     exit 0;
  }
  fi
}
fi

#echo_tests_info "$tests_dir"


#Check if we are printing tag list for current mode and exiting early
if [[ $small_list_flag -gt 0 ]]; then {
  if [[ $git_mode_flag -gt 0 || $base_mode_flag -gt 0 ]] ; then {
    echo_supported_tags "$milestones_dir"
  } elif [[ $test_mode_flag -gt 0 ]]; then {
    echo_tests_info "$kazoj_dir"
  }
  fi
  exit 0
}
fi

#Check if we are printing tag list for both modes and exiting early
if [[ $big_list_flag -gt 0 ]]; then {
  if [[ $git_mode_flag -gt 0 || $base_mode_flag -gt 0 ]] ; then {
    echo_supported_tags "$milestones_dir"
    echo_othermode_tags "$milestones_dir"
  } elif [[ $test_mode_flag -gt 0 ]]; then {
    echo_tests_info "$kazoj_dir"
  }
  fi
  exit 0
}
fi

#If version for makefile support was not specified, it's read from the stego.lock (an empty value would work maybe)
#We notify in verbose mode or not in quiet mode
if [[ -z $makefile_version ]] ; then {
  set_source_info "$milestones_dir"
  makefile_version=${sources_info[2]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -F flag, reading stego.lock for target makefile support version.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -E argument if we're in verbose mode or not in quiet mode
if [[ -z $exec_entrypoint ]] ; then {
  set_source_info "$milestones_dir"
  exec_entrypoint=${sources_info[1]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -E flag, reading stego.lock for target bin.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -S argument if we're in verbose mode or not in quiet mode
if [[ -z $source_name ]] ; then {
  set_source_info "$milestones_dir"
  source_name=${sources_info[0]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -S flag, reading stego.lock for target sourcename.\e[0m" >&2 # && usage && exit 1
}
fi

#Display needed values if in verbose mose
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]]  && [[ ! $dir_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using target dir: ( $scripts_dir ).\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $exec_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using target bin: ( $exec_entrypoint ).\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $sourcename_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using source file name: ( $source_name ).\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $vers_make_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using tag for make support: ( $makefile_version ) as first tag compiled with make.\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ $test_mode_flag -gt 0 && ! $test_info_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using tests dir: ( $kazoj_dir ).\e[0m" >&2

#Check if we are doing init and we're not in test mode
#Which means we want to build all tags
if [[ $init_flag -gt 0 && $test_mode_flag -eq 0 ]] ; then {
  count_bins=0
  start_t_init=`date +%s.%N`
  for i in $(seq 0 $(($tot_vers-1))); do
    init_vers="${supported_versions[$i]}"
    #Build this vers
    #Init mode ALWAYS tries building, even if we have the binary already ATM
    #Save verbose flag
    verb=""
    gitm=""
    basem=""
    quietm=""
    [[ $verbose_flag -gt 0 ]] && verb="V" && echo -e "\n[INIT]    Trying to build ( $init_vers ) ( $(($i+1)) / $tot_vers )" >&2
    [[ $base_mode_flag -gt 0 ]] && basem="B" #We make sure to pass on eventual base mode to the subcalls
    [[ $git_mode_flag -gt 0 ]] && gitm="g" #We make sure to pass on eventual git mode to the subcalls
    [[ $quiet_flag -gt 0 ]] && quietm="q" #We make sure to pass on eventual quiet flag mode to the subcalls
    #First pass sets the verbose flag but redirects stderr to /dev/null
    $prog_name -M "$makefile_version" -S "$source_name" -E "$exec_entrypoint" -D "$scripts_dir" -b"$verb""$gitm""$basem""$quietm" "$init_vers" 2>/dev/null
    if [[ $? -eq 0 ]] ; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[INIT]    $init_vers binary ready.\e[0m" >&2
      count_bins=$(($count_bins +1))
    } else {
      verbose_hint=""
      [[ $verbose_flag -lt 1 ]] && verbose_hint="Run with -V to see more info."
      echo -e "\n\033[1;31m[INIT]    Failed build for $init_vers binary. $verbose_hint\e[0m\n"
      #try building again to get more output, since we discarded stderr before
      #
      #we could just pass -v to the first call if we have it on
      if [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]]; then {
	echo -e "[INIT]    Checking errors, running \033[1;33m$(basename "$prog_name") -bV $init_vers\e[0m." >&2
	("$prog_name" -M "$makefile_version" -S "$source_name" -D "$scripts_dir" -E "$exec_entrypoint" -bV"$gitm""$basem" "$init_vers") >&2
      }
      fi
    }
    fi
  done
  end_t_init=`date +%s.%N`
  runtime_init=$( echo "$end_t_init - $start_t_init" | bc -l )
  display_zero=$(echo $runtime_init | cut -d '.' -f 1)
  if [[ -z $display_zero ]]; then {
    display_zero="0"
  } else {
    display_zero=""
  }
  fi
  echo -e "[INIT]    Took $display_zero$runtime_init seconds, ( $count_bins / $tot_vers ) binaries ready."
  #We don't quit after the full build.
  #exit 0
}
fi

if [[ $init_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  echo -e "\033[0;35m[TEST]    [-i]\e[0m    Will record all tests." >&2
}
fi
if [[ $purge_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  :
  #echo -e "\033[0;35m[TEST]    [-p]\e[0m    Will clean all tests." >&2
}
fi
if [[ $build_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  echo -e "\033[0;35m[TEST]    [-b]\e[0m    Will record test query." >&2
}
fi
if [[ $delete_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  :
  #echo -e "\033[0;35m[TEST]    [-d]\e[0m    Will clean test query." >&2
}
fi

quietm=""
verbm=""
[[ $quiet_flag -gt 0 ]] && quietm="q"
[[ $verbose_flag -gt 0 ]] && verbm="V"

#If we have -t and not -T, we always check all tests
if [[ $test_mode_flag -gt 0 && $big_test_mode_flag -eq 0 ]] ; then {
  for i in $(seq 0 $(($tot_tests-1))); do {
    echo -e "\033[1;34m[TEST]    Run:  \"$prog_name -Tt$quietm$verbm -K $kazoj_dir -D $milestones_dir ${supported_tests[$i]}\"\e[0m"
    "$prog_name" -Tt"$quietm""$verbm" -K "$kazoj_dir" -D "$milestones_dir" "${supported_tests[$i]}"
  }
  done
  #echo -e "\033[0;35m[TEST]    [-d]\e[0m    Will clean test query." >&2
}
fi

#Version argument is mandatory outside of:
  # purge or init mode (when not in test mode
  # init mode or FULL test mode (when in test mode)
#check arg num
# nothing else is allowed
#shift all the options
for i in $(seq 0 $(( $tot_opts - 2 )) ); do {
  shift
}
done

# $0 is now target version, at position 1 in the array ??
v_pos=1
query="${!v_pos}"

tot_left_args=$(( $# ))
if [[ $tot_left_args -gt 1 ]]; then {
  echo -e "\n\033[1;31m[ERROR]    Unknown argument: "$2".\e[0m\n"
  usage
  exit 1
}
fi


#If we don't have init or purge flag, we bail on a missing version argument
if [[ $tot_left_args -lt 1 && $purge_flag -eq 0 && $init_flag -eq 0 && $test_mode_flag -eq 0 ]]; then {
  echo -e "\033[1;31m[ERROR]    Missing query.\e[0m\n"
  echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
  exit 1
} elif [[ $tot_left_args -lt 1 && $test_mod_flag -gt 0 ]] ; then {
  #If in test mode, we still whine about a target test
  echo -e "\033[1;31m[ERROR]    Missing test query.\e[0m\n"
  echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
  echo "can we do init/purge?"
}
fi
#Check if we are doing a test
if [[ $test_mode_flag -gt 0 ]]; then {
  #We expect $scripts_dir to end with /
  test_name=""
  test_type=""
  test_path=""
  for i in $(seq 0 $(($count_tests_names-1))); do {
    current_item="${read_tests_files[$i]}"
    #echo "checking $current_item"
    if [[ $query = $current_item ]]; then {
      test_type="casetest"
      test_name="$query"
      test_path="$kazoj_dir/$cases_dir/${read_tests_files[$i]}"
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Checking cases ($i/$count_tests_names): $test_name\e[0m" >&2
      break; #done looking
    }
    fi
  }
  done
  if [[ -z $test_name ]] ; then {
    for i in $(seq 0 $(($count_errortests_names-1))); do {
      current_item="${read_errortests_files[$i]}"
      #echo "checking $current_item"
      if [[ $query = $current_item ]] ; then {
	test_type="errortest"
	test_name="$query"
	test_path="$kazoj_dir/$errors_dir/${read_errortests_files[$i]}"
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Checking error case ($i/$count_errortests_names): $test_name\e[0m" >&2
	break; #done looking
      }
      fi
    }
    done
  }
  fi

  if [[ -z $test_path && (( $init_flag -gt 0 || $build_flag -gt 0 )) ]]; then {
    #We may only freak out if we don't have init flag on
    if [[ -z $test_path && -z $query ]] ; then {
      keep_run_txt=""
      [[ $init_flag -gt 0 ]] && keep_run_txt="[INIT]" && echo -e "\033[1;33m[TEST]    ( \"empty\"[$query] ) is not a supported tag. $keep_run_txt.\e[0m" >&2 ; exit 1
    } elif [[ -z $test_path && ! -z $query ]] ; then {
      keep_run_txt=""
      [[ $init_flag -gt 0 ]] && keep_run_txt="[INIT]" && echo -e "\033[1;33m[TEST]    ( $query ) is not a supported tag, we quit at this point. $keep_run_txt.\e[0m" >&2 && exit 0
      [[ $build_flag -gt 0 ]] && keep_run_txt="[BUILD]" && echo -e "\033[1;33m[TEST]    ( $query ) is not a supported tag, but we continue to $keep_run_txt.\e[0m" >&2
    } else {
      [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[0;33m[TEST] expected:\n  $test_type\n\n  name: $test_name\n  path: $test_path\e[0m"# >&2
      echo -e "\033[0;32m[TEST]    target: ( $test_path ).\e[0m\n"
    }
    fi
  } elif [[ -z $test_path && -z $query ]] ; then {
    #Panic
    echo -e "\033[1;31m[ERROR]    ( $test_name : at  $test_path ) is not a supported test.\e[0m\n"
    echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
    exit 1
  }
  fi

  relative_testpath="$test_path"

  if [[ $build_flag -gt 0 ]] ; then {
    echo -e "\033[0;34m[TEST]    \"-b\" is set, Recording: ( $relative_testpath ).\e[0m" >&2
    #record_test "$relative_testpath"
  } elif [[ $delete_flag -gt 0 ]] ; then {
    :
    #echo -e "\033[0;34m[TEST]    \"-d\" is set, Deleting: ( $relative_testpath ).\e[0m" >&2
    #delete_test "$relative_testpath"
  } elif [[ $init_flag -gt 0 ]] ; then {
    echo -e "\033[0;34m[TEST]    \"-i\" is set, Recording ALL: ( $relative_testpath ).\e[0m"
    echo -e "\033[1;33m[DEBUG]    ( $tot_tests ) total tests ready.\e[0m" >&2
    for i in $(seq 0 $(($tot_tests-1))); do {
      TEST="${supported_tests[$i]}"
      verb=""
      quietm=""
      [[ $quiet_flag -gt 0 ]] && quietm="q" #We make sure to pass on eventual quiet flag mode to the subcalls
      [[ $verbose_flag -gt 0 ]] && verb="V" && echo -e "\n[TEST]    Recording ALL: ( $(($i+1)) / $tot_tests ) ( $TEST )" >&2
      start_t=`date +%s.%N`
      ( "$prog_name" -K "$kazoj_dir" -D "$scripts_dir" -b"$quietm""$verb"Tt "$TEST" 2>/dev/null ; exit "$?")
      record_res="$?"
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
      echo -e "\n[TEST]    took $runtime s ( $TEST )" >&2
    }
    done
    #init_all_tests "$relative_testpath"
  } elif [[ $purge_flag -gt 0 ]] ; then {
    :
    #echo "[TEST]    Deleting ALL: ( $relative_testpath )."
    #purge_all_tests "$relative_testpath"
  }
  fi
  if [[ -z $relative_testpath && $init_flag -eq 0 ]] ; then {
    #Exit 0 as intended behaviour FIXME
    echo -e "\033[1;33m[TEST]    Can't proceed further with no valid target path, query was ( $query ). Quitting.\e[0m" && exit 0
  }
  fi
  if [[ -z $relative_testpath && $init_flag -eq 1 && ! -z $query ]] ; then {
    #Exit 0 as intended behaviour FIXME
    echo -e "\033[1;31m[ERROR]    Can't proceed even with -i flag, with no testpath. ( p: $relative_testpath ) can't be be ( q: $query ).\e[0m" && exit 0
  }
  fi
  if [[ -z $relative_testpath && $init_flag -eq 1 && -z $query ]] ; then {
    echo -e "\033[1;31m[ERROR]    Can't proceed with no query.  ( q: $query, p: $relative_testpath ).\e[0m"
    exit 1
  }
  fi
  run_tmp_out="$(mktemp)"
  run_tmp_escout="$(mktemp)"
  run_tmp_err="$(mktemp)"
  run_tmp_escerr="$(mktemp)"
  echo -e "\033[1;33m[TEST]    Running ( $relative_testpath ).\e[0m"
  run_test "$relative_testpath" >>"$run_tmp_out" 2>>"$run_tmp_err"
  ran_res="$?"
  echo "r: $ran_res" >> "$run_tmp_out"
  escape_colorcodes_tee "$run_tmp_out" "$run_tmp_escout"
  escape_colorcodes_tee "$run_tmp_err" "$run_tmp_escerr"
  if [[ $build_flag -gt 0 ]] ; then {
    :
    cp "$run_tmp_escout" "$relative_testpath.stdout" || echo -e "Failed replacing stdout with new file."
    cp "$run_tmp_escerr" "$relative_testpath.stderr" || echo -e "Failed replacing stderr with new file."
  } else {
    :
  }
  fi
  rm -f "$run_tmp_out" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_out). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_out".\e[0m" >&2
  rm -f "$run_tmp_err" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_err). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_err".\e[0m" >&2
  #Testing diff for escaped stdout
  ( diff "$run_tmp_escout" "$relative_testpath".stdout ) 2>/dev/null 1>&2
  diff_res="$?"
  out_res=""
  if [[ "$diff_res" -eq 0 ]]; then {
    out_res="pass"
    if [[ ! -z "$run_tmp_escout" && ! -z "$relative_testpath.stdout" ]]; then {
      #This one doesn't go on stderr since we still want it in recursive calls:
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Pass, both outputs are not empty.\e[0m"
    } elif [[ -z "$run_tmp_escout" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, current stdout is empty. Is that expected?\e[0m">&2
    } elif [[ -z "$relative_testpath.stdout" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, registered stdout is empty. Is that expected?\e[0m" >&2
    }
    fi
    if [[ $verbose_flag -gt 0 ]]; then {
      echo -e "\n\033[1;35m[TEST]    (stdout) Expected:\e[0m"
      cat "$relative_testpath.stdout"
      echo -e "\n\033[1;35m[TEST]    (stdout) Found:\e[0m"
      cat "$run_tmp_escout"
    }
    fi
  } else {
    out_res="fail"
    echo -e "\n\033[1;31m[TEST]    (stdout) Expected:\e[0m"
    cat "$relative_testpath.stdout"
    echo -e "\n\033[1;31m[TEST]    (stdout) Found:\e[0m"
    cat "$run_tmp_escout"
    echo -e "\n\033[1;31m[TEST]    Failed: stdout changed.\e[0m"
    #cat "$run_tmp_escout"
  }
  fi
  rm -f "$run_tmp_escout" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_escout). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_escout".\e[0m" >&2
  #Testing diff for escaped stderr
  ( diff "$run_tmp_escerr" "$relative_testpath".stderr ) 2>/dev/null 1>&2
  diff_res="$?"
  if [[ "$diff_res" -eq 0 ]]; then {
    err_res="pass"
    if [[ ! -z "$run_tmp_escerr" && ! -z "$relative_testpath.stderr" ]]; then {
      #This one doesn't go on stderr since we still want it in recursive calls:
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Pass, both stderrs are not empty.\e[0m"
    } elif [[ -z "$run_tmp_escerr" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, current run stderr is empty. Is that expected?\e[0m">&2
    } elif [[ -z "$relative_testpath.stderr" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, registered stderr is empty. Is that expected?\e[0m" >&2
    }
    fi
    if [[ $verbose_flag -gt 0 ]]; then {
      echo -e "\n\033[1;35m[TEST]    (stderr) Expected:\e[0m"
      cat "$relative_testpath.stderr"
      echo -e "\n\033[1;35m[TEST]    (stderr) Found:\e[0m"
      cat "$run_tmp_escerr"
    }
    fi
    #cat "$run_tmp_escerr"
  } else {
    err_res="fail"
    echo -e "\n\033[1;31m[TEST]    (stderr) Expected:\e[0m"
    cat "$relative_testpath.stderr"
    echo -e "\n\033[1;31m[TEST]    (stderr) Found:\e[0m"
    cat "$run_tmp_escerr"
    echo -e "\n\033[1;31m[TEST]    Failed: stderr changed.\e[0m"
    #cat "$run_tmp_escerr"
  }
  fi
  rm -f "$run_tmp_escerr" || echo "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_escerr). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_escerr".\e[0m" >&2
  if [[ $build_flag -gt 0 ]] ; then {
    #We simulate success since we're recording
    echo -e "\033[1;35m[TEST]    Phony pass (recording).\e[0m"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m    (out: $out_res)\e[0m"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m    (err: $err_res)\e[0m"
    exit 0 #We return earlier
  } elif [[ $out_res = "pass" && $err_res = "pass" ]]; then {
    echo -e "\033[1;32m[TEST]    Passed.\e[0m"
    exit 0 #We return earlier
  } elif [[ $out_res = "fail" ]] ; then {
   : #echo "failed" #We echoed before
  } elif [[ $err_res = "fail" ]] ; then {
   : #echo "failed" #We echoed before
  } else {
    echo -e "\033[1;31m[ERROR]    Unexpected values (o:$out_res/e:$err_res) should be either pass or fail.\e[0m. How?"
  }
  fi
  exit 1
}
fi
#End of test mode block

#We expect $scripts_dir to end with /
version=""
for i in $(seq 0 $(($tot_vers-1))); do
  [[ $query = ${supported_versions[$i]} ]] && version="$query" && script_path=""$scripts_dir"v"$version""
done

if [[ -z $version ]]; then {
  #We only freak out if we don't have test_mode, purge or init flags on
  if [[ $test_mode_flag -eq 0 && $purge_flag -eq 0 && $init_flag -eq 0 ]] ; then {
    echo -e "\033[1;31m[ERROR]    ( $query ) is not a supported tag.\e[0m\n"
    echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
    exit 1
  } elif [[ ! -z $query && $test_mode_flag -gt 0 ]] ; then { #If we're in test mode, gently tell the user that the version is not supported
    keep_run_txt=""
    [[ $init_flag -gt 0 ]] && keep_run_txt="$mode_txt[INIT]"
    [[ $purge_flag -gt 0 ]] && keep_run_txt="$mode_txt[PURGE]"
    echo -e "\n\033[1;33m[DEBUG]    ( $query ) is not a supported test. $keep_run_txt.\e[0m" >&2
    exit 1;
  }
  fi
}
fi
#We now should have a valid $version value, outside of purge or init mode

has_makefile=0
if [[ $version > $makefile_version || $version = $makefile_version ]] ; then
  has_makefile=1
fi

#If we can't find the file we may try to build it
if [[ ! -f "$script_path/$exec_entrypoint" && ! -z $version ]] ; then {
  echo -e "\n\033[1;33m[QUERY]    ( $version ) binary not found in ( $script_path ).\e[0m" #>&2
  if [[ ! $build_flag -gt 0 ]] ; then { #We exit here if we don't want to try building and we're not going to purge
    echo -e "\033[0;33m[DEBUG]    To try building, run with -b flag\e[0m\n" >&2
    [[ ! $purge_flag -gt 0 ]] && exit 1 # quit if we're not purging
  } else {
    if [[ ! -d "$script_path" ]] ; then
      echo -e "\033[1;31m[ERROR]    '$script_path' is not a valid directory.\n    Check your supported versions for details on ( $version ).\e[0m\n" >&2
      exit 1
    fi
    #we try to build
    tool_txt="single file gcc"
    if [[ $has_makefile -gt 0 ]]; then { #Make mode
      tool_txt="make"
      echo -e "\033[0;33m[MODE]    target ( $version ) >= ( $makefile_version ), has Makefile.\e[0m" >&2
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Building ( $version ), using make.\e[0m" >&2
      curr_dir=$(realpath .)
      start_t=`date +%s.%N`
      if [[ $git_mode_flag -eq 0 && $base_mode_flag -eq 1 ]] ; then { #Building in base mode, we cd into target directory before make
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[BUILD]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
        cd $script_path; make >&2
        comp_res=$?
      } else { #Building in git mode, we checkout the tag and move the binary after the build
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;34m[BUILD]    Running in git mode, checking out ( $version ).\e[0m" #>&2
        git checkout "$version" 2>/dev/null #Repo goes back to tagged state
        checkout_res=$?
        if [[ $checkout_res -gt 0 ]] ; then { #Checkout failed, we don't build and we set comp_res
          echo -e "\033[1;31m[ERROR]    Checkout of ( $version ) failed, this stego.lock tag does not work for the repo.\e[0m" #>&2
          comp_res=1
        } else { #Checkout successful, we build
          git submodule update --init --recursive 2>/dev/null #We set all submodules to commit state
          make >&2 #Never try to build if checkout fails
          comp_res=$?
          #Output is expected to be in the main dir:
          if [[ ! -e ./$exec_entrypoint ]] ; then {
            echo -e "\033[1;31m[ERROR]    $exec_entrypoint not found at ($pwd).\e[0m" #>&2
          } else {
            mv "./$exec_entrypoint" "$script_path" #All files generated during the build should be ignored by the repo, to avoid conflict when checking out
            [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Moved $exec_entrypoint to $script_path.\e[0m" #>&2
          }
          fi
          git switch - 2>/dev/null #We get back to starting repo state
          switch_res="$?"
          [[ $switch_res -gt 0 ]] && echo -e "\n\033[1;31m[ERROR]    Can't finish checkin out ($version). Abort." && exit 1
          [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[BUILD]    Switched back to starting commit.\e[0m" >&2
        }
        fi
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
      cd "$curr_dir"
    } else { #Straight gcc mode
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[MODE]    target ( $version ) < ( $makefile_version ), single file build with gcc.\e[0m" >&2
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Building ( $version ), using gcc call.\e[0m" >&2
      #echo "" >&2 #new line for error output
      [[ -z $source_name ]] && echo -e "\n\033[1;31m[WTF-ERROR]    Missing source file name. ( $version ).\e[0m\n" && usage && exit 1

      start_t=`date +%s.%N`
      if [[ $git_mode_flag -eq 0 ]] ; then { #Building in base mode, we cd into target directory before make
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[BUILD]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
        gcc "$script_path"/"$source_name" -o "$script_path"/"$exec_entrypoint" -lm 2>&2
        comp_res=$?
      } else { #Building in git mode, we checkout the tag and move the binary after the build
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;34m[BUILD]    Running in git mode, checking out ( $version ).\e[0m" #>&2
        git checkout "$version" 2>/dev/null #Repo goes back to tagged state
        checkout_res=$?
        if [[ $checkout_res -gt 0 ]] ; then { #Checkout failed, we set comp_res and don't build
          echo -e "\033[1;31m[ERROR]    Checkout of ( $version ) failed, stego.lock may be listing a tag name not on the repo.\e[0m"
          comp_res=1
        } else {
          git submodule update --init --recursive 2>/dev/null#We set all submodules to commit state
          gcc "./$source_name" -o "$script_path"/"$exec_entrypoint" -lm 2>&2 #Never try to build if checkout fails
          comp_res=$?
          #All files generated during the build should be ignored by the repo, to avoid conflict when checking out
          git switch - 2>/dev/null #We get back to starting repo state
          switch_res="$?"
          [[ $switch_res -gt 0 ]] && echo -e "\n\033[1;31m[ERROR]    Can't finish checkin out ($version). Abort." && exit 1
          [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[BUILD]    Switched back to starting commit.\e[0m" >&2
        }
        fi
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
    }
    fi
    #Check compilation result
    if [[ $comp_res -eq 0 ]] ; then
      echo -e "\n\033[1;32m[BUILD]    Done Building ( $version ) , took $runtime seconds, using ( $tool_txt ).\e[0m"
    else
      echo -e "\n\033[1;31m[ERROR]    Build for ( $version ) failed, quitting.\e[0m\n" >&2
      exit 1
    fi

  }
  fi

} elif [[ ! -z $version ]] ; then { #Binary was present, we notify if we were running with build flag
  echo -e "\n\033[1;32m[QUERY]    ( $version ) binary is ready at ( $script_path ) .\e[0m" >&2
  [[ $build_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Found binary for ( $version ), won't build.\e[0m" >&2
} elif [[ ! -z $query ]] ; then {
  echo -e "\033[1;31m[QUERY]    ( $query ) invalid query, run with -V to see more.\e[0m"
}
fi

#We check the run flag to run the binary
if [[ ! -z $version && $run_flag -eq 1 && -x $script_path/$exec_entrypoint ]] ; then {
  echo -en "\n\033[0;32m[DEBUG]    Running script $script_path/$exec_entrypoint\e[0m"
  sleep 1
  echo -n "."
  sleep 1
  echo -n "."
  sleep 1
  echo -n "."
  sleep 1
  echo ""
  ( cd "$script_path" ; ./"$exec_entrypoint" )
} elif [[ ! -z $version && $run_flag -eq 0  ]] ; then {
  echo -e "\033[0;33m[DEBUG]    Running without -r flag, won't run.\e[0m" >&2
} elif [[ -z $version && $run_flag -gt 0 ]] ; then {
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[DEBUG]    Running with -r but requested an empty tag ( $version )!\e[0m" >&2
}
fi

#Check if we are deleting and exiting early
#We skipped first deletion pass if purge mode is requested, since we will enter here later
if [[ $delete_flag -gt 0 && $purge_flag -eq 0 ]] ; then {
    clean_res=1
  if [[ $has_makeclean -gt 0 && $base_mode_flag -gt 0 ]] ; then { #Running in git mode skips make clean
    tool_txt="make clean"
    has_bin=0
    curr_dir=$(realpath .)
    delete_path="$scripts_dir""v""$version"
      if [[ ! -d $delete_path ]] ; then {
        echo -e "\033[1;31m[ERROR]    '$delete_path' is not a valid directory.\n    Check your supported versions for details on ( $version ).\e[0m\n" #>&2
      } elif [[ -x $scripts_dir/v$version/$exec_entrypoint ]] ; then { #Executable exists
        has_bin=1 && echo -e "\033[0;33m[DELETE]   ( $version ) has an executable.\e[0m\n" >&2
        cd "$delete_path"; make clean 2>/dev/null #1>&2
        clean_res=$?
        cd "$curr_dir"
        exit "$clean_res"
      } else {
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;31m[DELETE]   ( $versions ) does not have an executable at ( $delete_path ).\e[0m\n" # >&2
           exit 1
      }
      fi
  } else { #Doesn't have Makefile, build method 2. Running in git mode also skips using make clean
    tool_txt="rm"
    has_bin=0
    if [[ -x $scripts_dir"/v$version"/"$exec_entrypoint" ]] ; then {
      has_bin=1 && [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[DELETE]    ( $version ) has an executable.\e[0m" >&2
    }
    fi
    rm $(realpath "$scripts_dir"/"v$version/$exec_entrypoint") #2>/dev/null
    clean_res=$?
    if [[ $clean_res -eq 0 ]] ; then {
      echo -e "\033[0;32m[DELETE]    Success on ( $version ).\e[0m" >&2
    } else {
      echo -e "\033[0;31m[DELETE]    Failure on ( $version ).\e[0m" >&2
    }
    fi
    exit "$clean_res"
  }
  fi
}
fi

#Check if we are purging
if [[ purge_flag -gt 0 ]]; then
  #echo "" >&2 #This newline can be redirected when doing recursion for init mode
  tot_removed=0
  tool_txt="rm"
  has_bin=0
  for i in $(seq 0 $(($tot_vers-1)) ); do
    clean_res=1
    has_makeclean=0
    purge_vers=${supported_versions[$i]}
    if [[ -x $scripts_dir/v$purge_vers/$exec_entrypoint ]] ; then {
      has_bin=1 #&& [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[DELETE]    $version has an executable.\e[0m\n" >&2
    } else {
      continue; #We just skip the version
    }
    fi
    if [[ $purge_vers > "$makefile_version" || $purge_vers = "$makefile_version" ]] ; then
      [[ $git_mode_flag -eq 0 ]] && has_makeclean=1 && tool_txt="make clean" #We never use make clean for purge, if in git mode
    fi

    ## Rerun with -d
    verb=""
    gitm=""
    basem=""
    quietm=""
    [[ $verbose_flag -gt 0 ]] && verb="V" && echo -e "\n[PURGE]    Trying to delete ( $purge_vers ) ( $(($i+1)) / $tot_vers )" >&2
    [[ $base_mode_flag -gt 0 ]] && basem="B" #We make sure to pass on eventual base mode to the subcalls
    [[ $git_mode_flag -gt 0 ]] && gitm="g" #We make sure to pass on eventual git mode to the subcalls
    [[ $quiet_flag -gt 0 ]] && quietm="q" #We make sure to pass on eventual quiet flag mode to the subcalls
    ( $prog_name -M "$makefile_version" -S "$source_name" -E "$exec_entrypoint" -D "$scripts_dir" -d"$verb""$gitm""$basem""$quietm" "$purge_vers" ) 2>/dev/null
    clean_res="$?"

    #Check clean result
    if [[ $clean_res -eq 0 && $has_bin -gt 0 ]] ; then {
      #we advance the count
      tot_removed=$(($tot_removed +1))
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[PURGE]    Removed ( $purge_vers ) using ( $tool_txt ).\e[0m" >&2
    } else {
      verbose_hint=""
      [[ $verbose_flag -lt 1 ]] && verbose_hint="Run with -V to see more info."
      echo -e "\n\033[1;31m[PURGE]    Failed delete for ( $purge_vers ) binary. $verbose_hint\e[0m\n"
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;31m[PURGE]    Failed removing ( $purge_vers ) using ( $tool_txt ). $verbose_hint\e[0m" #>&2
      #try deleting again to get more output, since we discarded stderr before
      #
      #we could just pass -v to the first call if we have it on
      if [[ $verbose_flag -gt 0 ]]; then {
	echo -e "[PURGE]    Checking errors, running \033[1;33m$(basename "$prog_name") -dV $purge_vers\e[0m." >&2
	("$prog_name" -M "$makefile_version" -S "$source_name" -D "$scripts_dir" -E "$exec_entrypoint" -dV"$gitm""$basem" "$purge_vers") #>&2
      }
      fi
    }
    fi

  done
  if [[ $tot_removed -gt 0 ]] ; then {
    echo -e "\033[0;33m[PURGE]    Purged ( $tot_removed / $tot_vers ) versions, quitting.\e[0m\n"
  } else {
    echo -e "\n\033[0;33m[PURGE]    No binaries to purge found.\e[0m\n"
  }
  fi
fi
exit 0
