#!/bin/bash
# Bash script to run a milestone build providing the version number.
# Will refuse to run as root. We don't need root privileges in here.
if [[ $- == *i* ]]; then {
  printf "amboso  Copyright (C) 2023  jgabaut\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w`.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c` for details.\n"
}
fi
amboso_start_time=`date +%s.%N`
if [[ "$EUID" -eq 0 ]] ; then {
  echo "[AMBOSO]    Please don't run me as root."
  exit 3
  echo_timer "$amboso_start_time"  "Root run" "3"
}
fi
# Set recursion env var if not exists
prog_name="$(readlink -f "$0")"
kernel_name="$(uname -s)"
kernel_release="$(uname -r)"
kernel_version="$(uname -v)"
machine_name="$(uname -m)"
os_name="$(uname -o)"
amboso_currvers="1.6.12"
expected_AMBOSO_API_LVL="1.6.12"
amboso_testflag_version="1.4.9"
export AMBOSO_LVL_REC="${AMBOSO_LVL_REC:-0}"
# check recursion
if [[ "${AMBOSO_LVL_REC}" -le "2" ]]; then
  PARENT_COMMAND=$(ps -o comm= $PPID)
  [[ $PARENT_COMMAND = "$prog_name" ]] && echo "Unexpected result while checking amboso recursion level." && exit 1
else
  echo -e "\n[AMBOSO]    Exceeded depth for recursion ( nested ${AMBOSO_LVL_REC} times).\n"
  echo_timer "$amboso_start_time"  "Excessive recursion" "1"
  exit 69
fi
#Increment depth counter
export AMBOSO_LVL_REC=$(($AMBOSO_LVL_REC+1))

#Functions to output dotfile
dotfile="./amboso_cfg.dot"
function app() {
  [[ $print_cfg_flag -eq 0 || ${AMBOSO_LVL_REC} -gt 1 ]] && return
  txt="$1" file="$dotfile"
  echo "$txt" >> "$file"
}
function echo_node() {
  frm="$1" nd="$2"
  echo " $frm -> $nd "
}
function echo_start_node() {
  sn="$1"
  echo -n " $sn ->"
}
function start_digraph() {
  app "digraph {"
}
function end_digraph() {
  app "}"
}

#Prepare flag values to default value
amboso_version="amboso version $amboso_currvers"
purge_flag=0
run_flag=0 #By default we don't run the binary
build_flag=0
delete_flag=0
init_flag=0
verbose_flag=0
quiet_flag=0
dir_flag=0
exec_entrypoint= #By default the value is empty
exec_was_set=0
source_name=
sourcename_was_set=0
bighelp_flag=0
smallhelp_flag=0
vers_make_flag=0
makefile_version=""
vers_autoconf_flag=0
use_autoconf_version=""
git_mode_flag=1 #By default we run in git mode
base_mode_flag=0
test_mode_flag=0
small_test_mode_flag=0
test_info_was_set=0
testdir_flag=0
kazoj_dir=""
big_list_flag=0
small_list_flag=0
version_flag=0
silent_flag=0
print_cfg_flag=0
pack_flag=0
tell_uname_flag=0
gen_C_headers_set=0
gen_C_headers_flag=0
gen_C_headers_destdir=""
start_time_flag=0
start_time_val=""
start_time_set=0
show_time_flag=0
ignore_git_check_flag=0

while getopts "A:M:S:E:D:K:G:W:wBgVbpHhrivdlLtTqsczUX" opt; do
  case $opt in
    X )
      ignore_git_check_flag=1
      ;;
    G )
      gen_C_headers_flag=1
      gen_C_headers_destdir="$OPTARG"
      if [[ ! -d $gen_C_headers_destdir ]] ; then {
	      echo -e "\033[1;31m[ERROR]    ($gen_C_headers_destdir) was not a valid directory.\e[0m"
	      echo -e "\033[1;33m[AMBOSO]    Run with -h for help.\e[0m"
  	      echo_timer "$amboso_start_time"  "Invalid dir for C gen" "1"
	      exit 1
      } else {
              gen_C_headers_set=1
      }
      fi
      ;;
    U )
      tell_uname_flag=1
      ;;
    c )
      print_cfg_flag=1
      ;;
    z )
      pack_flag=1
      ;;
    s )
      silent_flag=1
      ;;
    S )
      source_name="$OPTARG"
      sourcename_was_set=1
      ;;
    w )
      show_time_flag=1
      ;;
    W )
      start_time_val="$OPTARG"
      amboso_start_time="$start_time_val"
      start_time_set=1
      start_time_flag=1
      ;;
    E )
      exec_entrypoint="$OPTARG"
      exec_was_set=1
      ;;
    D )
      dir_flag=1
      milestones_dir="$OPTARG"
      ;;
    K )
      testdir_flag=1
      kazoj_dir="$OPTARG"
      test_info_was_set=1
      ;;
    M )
      vers_make_flag=1
      makefile_version="$OPTARG"
      ;;
    A )
      vers_autoconf_flag=1
      use_autoconf_version="$OPTARG"
      ;;
    L )
      big_list_flag=1
      ;;
    l )
      small_list_flag=1
      ;;
    H )
      bighelp_flag=1
      ;;
    h )
      smallhelp_flag=1
      ;;
    B )
      base_mode_flag=1
      ;;
    g )
      git_mode_flag=1
      ;;
    t )
      small_test_mode_flag=1
      ;;
    T )
      test_mode_flag=1
      ;;
    V )
      verbose_flag=$(($verbose_flag+1))
      ;;
    q )
      quiet_flag=1
      ;;
    v )
      version_flag=$(($version_flag+1))
      ;;
    p )
      purge_flag=1
      ;;
    r )
      run_flag=1
      ;;
    b )
      build_flag=1
      ;;
    d )
      delete_flag=1
      ;;
    i )
      init_flag=1
      ;;
    \? )
      echo "Invalid option: -$OPTARG. Run with -h for help." >&2
      echo_timer "$amboso_start_time"  "Invalid option: [$OPTARG]" "1"
      exit 1
      ;;
    : )
      echo "Option -$OPTARG requires an argument. Run with -h for help." >&2
      echo_timer "$amboso_start_time"  "Missing argument: [$OPTARG]" "1"
      exit 1
      ;;
  esac
tot_opts=$OPTIND
done

if [[ $print_cfg_flag -gt 0 ]] ; then {
  #Reset output file
  echo "" > "$dotfile"
  #Print opening digraph
  start_digraph
  start_node="start"
  #Unnecessary?
  #app "$( echo_start_node "$start_node" )"

  app "$( echo_node "$start_node" begin_node )"
}
fi

[[ $verbose_flag -gt 1 ]] && echo -e "\033[0;32m[PREP]    Done getopts.\e[0m" >&2
[[ $verbose_flag -gt 0 && ! $prog_name = "anvil" ]] && echo -e "\033[1;36m[AMBOZO]\e[0m    Please, symlink me to \"anvil\".\n" >&2

if [[ $(basename $(pwd)) == "amboso" ]] ; then {
  amboso_fn_path="$(realpath $(pwd))/amboso_fn.sh"
  if [[ -f $amboso_fn_path ]] ; then {
    [[ $verbose_flag -gt 1 ]] && echo -e "\033[0;35m[PREP]    Running inside amboso dir. Sourcing: \"$amboso_fn_path\".\e[0m" >&2
    source "$amboso_fn_path";
    source_res="$?"
    if [[ $source_res -ne 0 ]] ; then {
      echo -e "\033[1;31m[PREP]    Failed loading amboso_fn.\n\n    Using file: \"$amboso_fn_path\".\e[0m" >&2
      echo_timer "$amboso_start_time"  "Failed load of amboso_fn" "1"
      exit 3
    }
    fi
  } else {
    echo -e "\033[1;31m[ERROR]    Couldn't load amboso_fn, check your symlinks.\e[0m"
    echo_timer "$amboso_start_time"  "Invalid path [$amboso_fn_path]" "1"
    exit 2
  }
  fi
} else {
  amboso_fn_path="$(realpath $(pwd))/amboso/amboso_fn.sh"
  found_amboso_dir=0
  [[ $verbose_flag -gt 1 ]] && echo -e "\033[0;33m[PREP]    Assuming we are running in super-repo. Sourcing: \"$amboso_fn_path\".\e[0m" >&2
  [[ -d "$(realpath $(pwd))"/amboso ]] && found_amboso_dir=1
  [[ $verbose_flag -gt 1 && $found_amboso_dir -gt 0 ]] && echo -e "\033[0;32m[PREP]    Found amboso dir.\e[0m" >&2
  if [[ -f $amboso_fn_path ]] ; then {
    [[ $verbose_flag -gt 1 ]] && echo -e "\033[0;35m[PREP]    Valid file at: \"$amboso_fn_path\".\e[0m" >&2
    source "$amboso_fn_path";
    source_res="$?"
    [[ $source_res -ne 0 ]] && echo -e "\033[1;31m[PREP]    Failed loading amboso_fn.\n\n    Using file: \"$amboso_fn_path\".\e[0m" >&2
  } else {
    [[ $quiet_flag -eq 0 ]] && echo -e "\033[0;31m[WARN]    \"$amboso_fn_path\" was not a valid file. Not in valid super-repo.\e[0m" >&2 && try_default=1
  }
  fi
  if [[ $try_default -eq 1 && -f /usr/local/bin/amboso_fn.sh ]] ; then { #We only enter here if we failed sourcing
    #We need one more error message to show me are missing functions because of an amboso directory with no file.
    if [[ $found_amboso_dir -gt 0 ]] ; then {
      echo -e "\033[1;31m[WARN]   Deprecated amboso dir (< 1.4.3) found, as it doesn't provide a function api marker.\e[0m\n" >&2
      echo_timer "$amboso_start_time"  "Deprecated amboso dir found" "5"
      exit 3
    }
    fi
    amboso_fn_path="/usr/local/bin/amboso_fn.sh"
    [[ $quiet_flag -eq 0 ]] && echo -e "\033[0;35m[WARN]    Fallback to default path for amboso_fn. Sourcing: \"$amboso_fn_path\".\e[0m" >&2
    source "$amboso_fn_path";
    source_res="$?"
    if [[ $source_res -ne 0 ]] ; then {
      echo -e "\033[1;31m[PREP]    Failed loading amboso_fn. Quitting.\n\n    Using file: \"$amboso_fn_path\".\e[0m" >&2
      echo_timer "$amboso_start_time"  "Failed loading amboso_fn.sh" "1"
      exit 3
    }
    fi
  }
  fi
}
fi

if [[ $source_res -ne 0 ]] ; then {
  echo -e "\033[1;31m[PANIC]    Failed sourcing amboso_fn. Expected path: \"$amboso_fn_path\".\e[0m"
  app "$(echo_node begin_node failed_sourcing_fn)"
  app "$(echo_node failed_sourcing_fn end_node)"
  end_digraph
  echo_timer "$amboso_start_time"  "Failed loading amboso_fn.sh" "1"
  exit 2
}
fi
app "$(echo_node begin_node loaded_fn)"
[[ $verbose_flag -gt 1 ]] && echo -e "\033[0;32m[PREP]    Done loading functions.\e[0m" >&2
[[ $verbose_flag -gt 1 ]] && echo -e "\033[0;37m[PREP]    \"\$AMBOSO_API_LVL\" is: (\033[0;34m $AMBOSO_API_LVL \033[0;37m, expected { \033[1;33m$expected_AMBOSO_API_LVL\033[0;37m } ).\e[0m" >&2
[[ $tell_uname_flag -eq 1 ]] && print_sysinfo
if [[ $expected_AMBOSO_API_LVL > $AMBOSO_API_LVL ]] ; then {
  echo -e "\033[1;31m[PANIC]    AMBOSO_API_LVL not supported. Needed { \033[1;35m$expected_AMBOSO_API_LVL\033[1;31m } , { \033[1;33m$AMBOSO_API_LVL\033[1;31m } is too low.\n\n    Maybe check your \"amboso_fn.sh\" file.\n\e[0m"
  echo -e "\033[1;31m[PANIC]    Couldn't load functions. Quitting.\e[0m"
  echo_timer "$amboso_start_time"  "AMBOSO_API_LVL too low." "1"
  exit 2
} elif [[ $AMBOSO_API_LVL > $expected_AMBOSO_API_LVL ]] ; then {
  [[ $verbose_flag -gt 1 ]] && echo -e "\033[0;31m[WARN]    AMBOSO_API_LVL is greater than expected. Needed { \033[1;35m$expected_AMBOSO_API_LVL\033[0;31m } , { \033[1;34m$AMBOSO_API_LVL\033[0;31m } is higher.\e[0m" >&2
  [[ $verbose_flag -gt 1 ]] && echo -e "\n\033[1;31m[WARN]    Continuing run with unexpected AMBOSO_API_LVL: Needed { \033[1;35m$expected_AMBOSO_API_LVL\033[1;31m } , { \033[1;34m$AMBOSO_API_LVL\033[1;31m } is higher.\e[0m"
  #exit 2
} elif [[ $AMBOSO_API_LVL = $expected_AMBOSO_API_LVL ]] ; then {
  [[ $verbose_flag -gt 1 ]] && echo -e "\033[0;32m[PREP]   Running with \"\$AMBOSO_API_LVL\" [ \033[1;35m$AMBOSO_API_LVL\033[0;32m ]; min is { \033[1;36m$expected_AMBOSO_API_LVL\033[0;32m }.\e[0m" >&2
}
fi
[[ $verbose_flag -gt 1 ]] && echo -e "\033[0;32m[PREP]    Printing active flags:\e[0m" >&2 && echo_active_flags >&2
main_at=235
#PROG_START_LINE
prog_start_line="235"
trace_flag=0
trace_line="421"
# Check env var to enable backtrace
export AMBOSO_TRACING="${AMBOSO_TRACING:-0}"
if [[ ${AMBOSO_TRACING} -gt 0 ]]; then {
  trace_line=0
  trace_flag=1;
  printf "\033[0;37m[TRACE]    Tracing started.\e[0m\n" >&2
  trap backtrace DEBUG ERR
} else {
  : #echo "{No trace}" >&2
}
fi

[[ $verbose_flag -gt 1 ]] && echo -e "\033[0;37m[PREP]    Parent command is: ( $PARENT_COMMAND ).\e[0m" >&2


#Won't print call info for top level calls
if [[ ${AMBOSO_LVL_REC} -gt 1 ]] ; then {
#and 1+ nested test calls ( with -T, from -t calling -T)
  [[ $quiet_flag -eq 0 && $verbose_flag -gt 0 ]] && echo -e "\033[1;34m[AMBOSO]    Amboso depth: ( $((${AMBOSO_LVL_REC}-1)) )\e[0m"
  if [[ $AMBOSO_LVL_REC -lt 2 ]] ; then {
    echo -e "\\n\n        args: (\"$@\")" >&2
    echo_active_flags >&2
  } elif [[ $AMBOSO_LVL_REC -gt 2 ]] ; then {
    [[ $test_info_was_set -eq 1 ]] && echo -e "[AMBOSO]    Deep recursion (>1), are you calling \"$prog_name\" in a test? ;)" >&2
    #[[ $small_test_mode_flag -gt 0 ]] && echo "[ERROR]    Can't proceed and macro -t for -T on all tags." && exit 69
    #[[ $test_mode_flag -gt 0 ]] && echo "[ERROR]    Can't proceed with test mode." && exit 69
  }
  fi
} elif [[ $AMBOSO_LVL_REC -eq 1 ]] ; then {
    #Print lvl info for top level calls
    #echo "AMBOSO_LVL_REC: [$AMBOSO_LVL_REC]" >&2
    :
}
fi

if [[ $version_flag -eq 1 ]] ; then {
  echo_amboso_version_short
  echo_timer "$amboso_start_time"  "Version flag, 1" "2"
  exit 0
} elif [[ $version_flag -gt 1 ]] ; then {
  echo_amboso_version
  echo_timer "$amboso_start_time"  "Version flag, >1" "2"
  exit 0
}
fi

[[ "$AMBOSO_LVL_REC" -eq 0 ]] && echo -e "\033[1;35m[AMBOSO]    Current version: $amboso_currvers\e[0m\n"

app "$(echo_node loaded_fn silence_check)"

#We check if we have to silence all subsequent output
if [[ ( $test_mode_flag -eq 0 && $small_test_mode_flag -eq 0 ) && $silent_flag -gt 0 ]] ; then {
  echo -e "\033[1;33m[MODE]\e[0m    Running in silent mode, will now suppress all output.\n"
  echo_timer "$amboso_start_time"  "Silent run, turning off outputs" "2"
  exec 3>&1 &>/dev/null
  echo -e "This output is going to dev null"
  echo -e "This erroutput is going to dev null" >&2
}
fi

#We check again if testmode was requested, and reset the other mode flags.
# -T always overrides -g and -B
if [[ $test_mode_flag -gt 0 ]] ; then {
  git_mode_flag=0
  base_mode_flag=0
  echo -e "\033[1;33m[MODE]    Running in test mode.\e[0m" >&2
}
fi

#We check again if basemode was requested, as the only flag checked in build stage is git_mode_flag
#If base_mode_flag is asserted, we always override git_mode_flag

#Default mode with no flags should be git mode
if [[ $base_mode_flag -gt 0 ]] ; then {
  git_mode_flag=0
  echo -e "\033[1;31m[MODE]    Running in base mode, expecting full source builds.\e[0m" >&2
}
fi
if [[ $git_mode_flag -gt 0 ]] ; then {
  git_mode_check
  git_mode_check_res="$?"
  if [[ $git_mode_check_res -eq 0 ]]; then {
  	[[ $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[GIT]    Status was clean.\e[0m" >&2
  } else {
  	[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;31m[GIT]    Status was not clean!\e[0m" >&2
        if [[ $ignore_git_check_flag -eq 0 ]]; then {
  	  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;31m[AMBOSO]    Aborting.\e[0m" >&2
          echo_timer "$amboso_start_time"  "Dirty git status" "1"
	  exit 1
	}
	fi
  	[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;35m[AMBOZO]    We ignore this and will waste time.\e[0m" >&2
  }
  fi
}
fi

#We always notify of missing -D argument
[[ ! $dir_flag -gt 0 ]] && milestones_dir="./bin/" && echo -e "\033[1;33m[DEBUG]    No -D flag, using ( $milestones_dir ) for target dir. Run with -V to see more.\e[0m" >&2 #&& usage && exit 1

#We always notify of missing -K argument, if in test mode
if [[ $test_mode_flag -gt 0 && ! $testdir_flag -gt 0 ]] ; then {
  set_source_info "$milestones_dir"
  kazoj_dir="${sources_info[3]}"
  set_tests_info "$kazoj_dir"
  res="$?"
  [[ $res -eq 0 ]] || echo -e "\033[0;33m[WARN]\e[0m    Problems when doing set_tests_info($kazoj_dir).\n"
  set_supported_tests "$kazoj_dir"
  res="$?"
  [[ $res -eq 0 ]] || echo -e "\033[0;33m[WARN]\e[0m    Problems when doing set_supported_tests($kazoj_dir).\n"
  kazoj_dir="$(pwd)/kazoj/"
  [[ $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -K flag, using ( $kazoj_dir ) for target dir. Run with -V to see more.\e[0m" >&2 #&& usage && exit 1
}
fi
if [[ $test_mode_flag -gt 0 && $test_info_was_set -gt 0 ]] ; then {
  if [[ $AMBOSO_LVL_REC -lt 3 ]] ; then {
    app "$(echo_node silence_check test_mode)"
    app "$(echo_node test_mode recursion_lt_3)"
    echo -e "\033[1;32m[DEBUG]    bone dir: ( $cases_dir )\e[0m" >&2
    echo -e "\033[1;32m           kulpo dir: ( $errors_dir )\e[0m" >&2 #&& usage && exit 1
  } else {
    app "$(echo_node silence_check test_mode)"
    app "$(echo_node test_mode recursion_ge_3)"
    app "$(echo_node recursion_ge_3 end_node)"
    end_digraph
    [[ ! -z $cases_dir ]] && echo -e "\033[1;32m[DEBUG]    bone dir: ( $cases_dir )\e[0m" >&2
    [[ ! -z $errors_dir ]] && echo -e "\033[1;32m           kulpo dir: ( $errors_dir )\e[0m" >&2 #&& usage && exit 1
    echo -e "\n\033[1;31m[PANIC]    Running  as \"$prog_name\" in test mode is not supported. Quitting with 69.\e[0m\n" #&& usage && exit 1
    echo_timer "$amboso_start_time"  "Test calling \"$(basename $prog_name)\" in test mode to run a test with..." "1"
    exit 69
    #We return 69 and will check for this somewhere
  }
  fi
} elif [[ $test_info_was_set -eq 0 && $test_mode_flag -gt 0 ]] ; then {
    app "$(echo_node silence_check test_mode)"
    app "$(echo_node test_mode no_test_info)"
  if [[ $AMBOSO_LVL_REC -lt 3 ]] ; then {
    app "$(echo_node no_test_info recursion_lt_3)"
    echo -e "\033[1;33m[DEBUG]    bone dir (NO -K passed to this call): ( $cases_dir )\e[0m" >&2
    echo -e "\033[1;33m           kulpo dir (NO -K passed to this amboso call): ( $errors_dir )\e[0m" >&2 #&& usage && exit 1
  } else {
    app "$(echo_node no_test_info recursion_ge_3)"
    app "$(echo_node recursion_ge_3 end_node)"
    end_digraph
    #Deep case: we're running a test, calling a program that calls amboso in test mode.
    echo -e "\033[1;33m[DEBUG]    bone dir (NO -K passed to this call): ( $cases_dir )\e[0m" >&2
    echo -e "\033[1;33m           kulpo dir (NO -K passed to this amboso call): ( $errors_dir )\e[0m" >&2 #&& usage && exit 1

    echo -e "\n\033[1;31m[PANIC]    Running  \"$(basename $prog_name)\" using test mode in a program that will be called by test mode is not supported.\e[0m\n" >&2 #&& usage && exit 1
    echo_timer "$amboso_start_time"  "Test calling \"$(basename $prog_name)\" in test mode to run a test with..." "1"
    exit 1
  }
  fi
}
fi

#Check if we are printing help info and exiting early
if [[ $smallhelp_flag -gt 0 ]]; then {
    app "$(echo_node silence_check doing_help)"
    app "$(echo_node doing_help end_node)"
    end_digraph
  if [[ $AMBOSO_LVL_REC -gt 1 ]] ; then {
    echo -e "[AMBOSO]    can't ask for help on a recursive call, try running \"$prog_name -h\" from a shell. ( depth $((${AMBOSO_LVL_REC}-1)) )\n\n        args: (\"$@\")" >&2
    echo_timer "$amboso_start_time"  "Recursive help?" "1"
    exit 1
  }
  fi
  echo_amboso_version
  usage

  echo -e "Try running with with -H for more info.\n"
  #"$prog_name" -H -D "$milestones_dir" | less
  echo_timer "$amboso_start_time"  "Show help" "2"
  exit 0
}
fi
#Check if we are printing Help info and exiting early
if [[ $bighelp_flag -gt 0 ]]; then {
    app "$(echo_node silence_check doing_big_help)"
    app "$(echo_node doing_big_help end_node)"
    end_digraph
  if [[ $AMBOSO_LVL_REC -gt 1 ]] ; then {
    echo -e "[AMBOSO]    can't ask for help on a recursive call, try running \"$prog_name -H\" from a shell. ( depth $((${AMBOSO_LVL_REC}-1)) )\n\n        args: (\"$@\")" >&2
    echo_timer "$amboso_start_time"  "Recursive bighelp?" "1"
    exit 1
  }
  fi
  echo_amboso_version
  set_source_info "$milestones_dir"
  set_supported_versions "$milestones_dir"
  amboso_help
  echo_timer "$amboso_start_time"  "Show big help" "2"
  exit 0
}
fi

#Syncpoint: we assert we know these names after this. WIP

#TODO: check if scripts_dir is needed anywhere... why
scripts_dir="$milestones_dir" # MUST BE SET before checking for -S and -E
set_supported_versions "$scripts_dir" # Might as well do it now
set_source_info "$milestones_dir"
kazoj_dir="${sources_info[3]}" #TODO: don't think this should be overwritten here if assigned earlier
use_automake_version="${sources_info[4]}"
set_tests_info "$kazoj_dir"
set_supported_tests "$kazoj_dir"

if [[ $verbose_flag -gt 1 ]]; then {
    echo -e "\033[1;36m[FETCH]    Fetching remote tags\e[0m" >&2
    echo_tag_info $version
}
fi

if [[ $verbose_flag -gt 1 ]]; then { #WIP
    echo -e "\033[1;35m[VERB]    SYNCPOINT:  listing tag names\e[0m" >&2
    echo_supported_tags "$milestones_dir" >&2
    echo_tests_info "$kazoj_dir" >&2
}
fi

#If we're in test mode and test dir was not passed, we check if "./kazoj" is a directory and use that. If it isn't, we may get the name from stego.lock. If that is not a directory, we quit immediately.
if [[ -z $kazoj_dir && $test_mode_flag -gt 0 ]] ; then {
  if [[ "$amboso_currvers" > "$amboso_testflag_version" || "$amboso_currvers" = "$amboso_testflag_version" ]] ; then {
     if [[ -d "./kazoj" ]]; then {
       kazoj_dir="./kazoj"
       set_tests_info "$kazoj_dir"
       set_supported_tests "$kazoj_dir"
       [[ $quiet_flag -eq 0 || $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[DEBUG]  No -K flag on a test run (amboso > $amboso_testflag_version), using \"./kazoj\" as tests dir.\e[0m" >&2
     } else {
       [[ $quiet_flag -eq 0 || $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[DEBUG]  No -K flag on a test run (amboso > $amboso_testflag_version), reading stego.lock.\e[0m" >&2
       set_source_info "$milestones_dir"
       kazoj_dir="${sources_info[3]}"
       set_tests_info "$kazoj_dir"
       set_supported_tests "$kazoj_dir"
       [[ $quiet_flag -eq 0 || $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[DEBUG]  No -K flag on a test run (amboso > $amboso_testflag_version), reading stego.lock.\e[0m" >&2
     }
     fi
  } else {
     echo -e "\033[1;31m[ERROR]    No -K flag on a test run, amboso version is < ($amboso_testflag_version).\n    Quitting.\e[0m" #>&2
     echo_timer "$amboso_start_time"  "No -K on test run" "3"
     exit 0
  }
  fi
}
fi

#Check if we are printing tag list for current mode and exiting early
if [[ $small_list_flag -gt 0 ]]; then {
  if [[ $git_mode_flag -gt 0 || $base_mode_flag -gt 0 ]] ; then {
    echo_supported_tags "$milestones_dir"
  } elif [[ $test_mode_flag -gt 0 ]]; then {
    echo_tests_info "$kazoj_dir"
  }
  fi
  echo_timer "$amboso_start_time"  "List tags" "2"
  exit 0
}
fi

#Check if we are printing tag list for both modes and exiting early
if [[ $big_list_flag -gt 0 ]]; then {
  if [[ $git_mode_flag -gt 0 || $base_mode_flag -gt 0 ]] ; then {
    echo_supported_tags "$milestones_dir"
    echo_othermode_tags "$milestones_dir"
  } elif [[ $test_mode_flag -gt 0 ]]; then {
    echo_tests_info "$kazoj_dir"
  }
  fi
  echo_timer "$amboso_start_time"  "List all tags" "2"
  exit 0
}
fi

#If version for makefile support was not specified, it's read from the stego.lock (an empty value would work maybe)
#We notify in verbose mode or not in quiet mode
if [[ -z $makefile_version ]] ; then {
  set_source_info "$milestones_dir"
  makefile_version=${sources_info[2]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -F flag, reading stego.lock for target makefile support version.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -E argument if we're in verbose mode or not in quiet mode
if [[ -z $exec_entrypoint ]] ; then {
  set_source_info "$milestones_dir"
  exec_entrypoint=${sources_info[1]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -E flag, reading stego.lock for target bin.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -S argument if we're in verbose mode or not in quiet mode
if [[ -z $source_name ]] ; then {
  set_source_info "$milestones_dir"
  source_name=${sources_info[0]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -S flag, reading stego.lock for target sourcename.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -A argument if we're in verbose mode or not in quiet mode
if [[ -z $use_autoconf_version ]] ; then {
  set_source_info "$milestones_dir"
  use_autoconf_version=${sources_info[4]}
  [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[1;33m[DEBUG]    No -A flag, reading stego.lock for autoconf support version.\e[0m" >&2 # && usage && exit 1
}
fi

#Display needed values if in verbose mose
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]]  && [[ ! $dir_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using target dir: ( $scripts_dir ).\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $exec_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using target bin: ( $exec_entrypoint ).\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $sourcename_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using source file name: ( $source_name ).\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $vers_make_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using tag for make support: ( $makefile_version ) as first tag compiled with make.\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ ! $vers_autoconf_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using tag for automake support: ( $use_autoconf_version ) as first tag compiled with automake.\e[0m" >&2
[[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && [[ $test_mode_flag -gt 0 && ! $test_info_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using tests dir: ( $kazoj_dir ).\e[0m" >&2

#Check if we are doing init and we're not in test mode
#Which means we want to build all tags
#TODO: Why is this checked before determining if we're doing build mode or test mode?
if [[ $init_flag -gt 0 && $test_mode_flag -eq 0 && $small_test_mode_flag -eq 0 ]] ; then {
  if [[ $quiet_flag -eq 0 && $verbose_flag -gt 1 ]]; then { #WIP
      echo -e "\033[1;35m[VERB]    Init mode (no -tT): build all tags\e[0m" >&2
      echo_supported_tags "$milestones_dir" >&2
  }
  fi
  app "$(echo_node silence_check doing_init)"

  count_bins=0
  start_t_init=`date +%s.%N`
  for i in $(seq 0 $(($tot_vers-1))); do
    init_vers="${supported_versions[$i]}"
    [[ $quiet_flag -eq 0 ]] && echo -e "[INIT]    Trying to build ( $init_vers ) ( $(($i+1)) / $tot_vers )" >&2
    #Build this vers
    #Init mode ALWAYS tries building, even if we have the binary already ATM
    #Save verbose flag
    verb=""
    buildm=""
    gitm=""
    basem=""
    quietm=""
    silentm=""
    packm=""
    ignore_gitcheck=""
    showtimem=""
    [[ $ignore_git_check_flag -gt 0 ]] && ignore_gitcheck="X"
    [[ $show_time_flag -gt 0 ]] && showtimem="w"
    [[ $pack_flag -gt 0 ]] && packm="z" #Pass pack op mode
    [[ $silent_flag -gt 0 ]] && silentm="s" #Pass silent mode
    [[ $verbose_flag -gt 0 ]] && verb="V" #Pass verbose mode
    [[ $build_flag -gt 0 ]] && buildm="b" #Pass build op mode
    [[ $base_mode_flag -gt 0 ]] && basem="B" #We make sure to pass on eventual base mode to the subcalls
    [[ $git_mode_flag -gt 0 ]] && gitm="g" #We make sure to pass on eventual git mode to the subcalls
    [[ $quiet_flag -gt 0 ]] && quietm="q" #We make sure to pass on eventual quiet mode to the subcalls
    #First pass sets the verbose flag but redirects stderr to /dev/null
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[VERB]    Running \"$(dirname $(basename $prog_name)) -W $amboso_start_time -M $makefile_version -S $source_name -E $exec_entrypoint -D $scripts_dir -b$verb$gitm$basem$quietm$silentm$packm$ignore_gitcheck$showtimem $init_vers\" ( $(($i+1)) / $tot_vers )" >&2
    "$prog_name" -W "$amboso_start_time" -M "$makefile_version" -S "$source_name" -E "$exec_entrypoint" -D "$scripts_dir" -b"$verb""$gitm""$basem""$quietm""$silentm""$packm""$ignore_gitcheck""$showtimem" "$init_vers" 2>/dev/null
    if [[ $? -eq 0 ]] ; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[INIT]    $init_vers binary ready.\e[0m" >&2
      count_bins=$(($count_bins +1))
    } else {
      verbose_hint=""
      [[ $verbose_flag -lt 1 ]] && verbose_hint="Run with -V to see more info."
      echo -e "\n\033[1;31m[INIT]    Failed build for $init_vers binary. $verbose_hint\e[0m\n"
      #try building again to get more output, since we discarded stderr before
      #
      #we could just pass -v to the first call if we have it on
      if [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]]; then {
	echo -e "[INIT]    Checking errors, running \033[1;33m$(basename "$prog_name") -bV$packm$ignore_gitcheck $init_vers\e[0m." >&2
	("$prog_name" -W "$amboso_start_time" -M "$makefile_version" -S "$source_name" -D "$scripts_dir" -E "$exec_entrypoint" -bVV"$gitm""$basem""$packm""$ignore_gitcheck""$showtimem" "$init_vers") >&2
      }
      fi
    }
    fi
  done
  end_t_init=`date +%s.%N`
  runtime_init=$( echo "$end_t_init - $start_t_init" | bc -l )
  display_zero=$(echo $runtime_init | cut -d '.' -f 1)
  if [[ -z $display_zero ]]; then {
    display_zero="0"
  } else {
    display_zero=""
  }
  fi
  echo -e "\033[0;34m[INIT]    Took $display_zero$runtime_init seconds, ( $count_bins / $tot_vers ) binaries ready.\e[0m"
  #We don't quit after the full build.
  #exit 0
}
fi

if [[ $init_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  echo -e "\033[0;35m[TEST]    [-i]\e[0m    Will record all tests." >&2
}
fi
if [[ $purge_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  :
  #echo -e "\033[0;35m[TEST]    [-p]\e[0m    Will clean all tests." >&2
}
fi
if [[ $build_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  echo -e "\033[0;35m[TEST]    [-b]\e[0m    Will record test query." >&2
}
fi
if [[ $delete_flag -gt 0 && $test_mode_flag -gt 0 ]] && [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] ; then {
  :
  #echo -e "\033[0;35m[TEST]    [-d]\e[0m    Will clean test query." >&2
}
fi

#If we have -t and not -T, we check all tests and EXIT
#WIP
if [[ $small_test_mode_flag -gt 0 && $test_mode_flag -eq 0 ]] ; then {
  app "$(echo_node silence_check doing_test_macro)"
  app "$(echo_node doing_test_macro end_node)"
  end_digraph
  if [[ $quiet_flag -eq 0 ]] ; then {
    echo -e "\033[1;33m[DEBUG]    -t assert: shortcut to run \"$prog_name\" with -T"
    echo -e "\033[1;33m[DEBUG]    will pass: ( -qVbw ) to subcall, if asserted.\n"
  }
  fi
  quietm=""
  verbm=""
  buildm=""
  showtimem=""
  [[ $show_time_flag -gt 0 ]] && showtimem="w"
  [[ $quiet_flag -gt 0 ]] && quietm="q"
  [[ $verbose_flag -gt 0 ]] && verbm="V"
  [[ $build_flag -gt 0 ]] && buildm="b"
  [[ $init_flag -gt 0 ]] && buildm="b" && echo -e "\033[1;31m[DEBUG]    Recording all tests with -ti is deprecated.\n\n        Feature will be dropped in next major update.\n"

  tot_successes=0
  tot_failures=0
  start_t_tests=`date +%s.%N`
  for i in $(seq 0 $(($tot_tests-1))); do {
    [[ $quiet_flag -eq 0 ]] && echo -e "\033[1;35m[TEST-MACRO]    Running:  \"$prog_name -W $amboso_start_time -T$quietm$verbm$buildm$showtimem -K $kazoj_dir -D $milestones_dir ${supported_tests[$i]}\"\e[0m" >&2
    start_t_curr_test=`date +%s.%N`
    "$prog_name" -W "$amboso_start_time" -T"$quietm$verbm$buildm""$showtimem" -K "$kazoj_dir" -D "$milestones_dir" "${supported_tests[$i]}"
    retcod="$?"
    if [[ $retcod -eq 0 ]] ; then {
      tot_successes=$(($tot_successes+1))
    } else {
      tot_failures=$(($tot_failures+1))
    }
    fi
    if [[ $retcod -eq 69 ]] ; then {
      echo -e "\033[1;31m[PANIC]    A test call returned 69 while in macro mode. Doing the same.\e[0m\n"
      echo_timer "$amboso_start_time"  "Test returned 69" "1"
      exit 69
    }
    fi
    end_t_curr_test=`date +%s.%N`
    runtime_curr_test=$( echo "$end_t_curr_test - $start_t_curr_test" | bc -l )
    display_zero=$(echo $runtime_curr_test | cut -d '.' -f 1)
    if [[ -z $display_zero ]]; then {
      display_zero="0"
    } else {
      display_zero=""
    }
    fi
    [[ $quiet_flag -eq 0 ]] && echo -e "\033[0;34m[TEST]  ($(($i+1))/$tot_tests)  took $display_zero$runtime_curr_test seconds.\e[0m"
  }
  done
  end_t_tests=`date +%s.%N`
  runtime_tests=$( echo "$end_t_tests - $start_t_tests" | bc -l )
  display_zero=$(echo $runtime_tests | cut -d '.' -f 1)
  if [[ -z $display_zero ]]; then {
    display_zero="0"
  } else {
    display_zero="" #what?
  }
  fi
  #echo -e "\033[0;34m[TEST]    Full testing took $display_zero$runtime_tests seconds ( $tot_tests done).\e[0m\n"
  echo_timer "$amboso_start_time"  "Test macro" "6"
  exit $tot_failures
} elif [[ $small_test_mode_flag -gt 0 && $test_mode_flag -gt 0 ]] ; then {
  echo -e "\033[1;31m[PANIC]    [-t] used with [-T].\n\n        -t is a shortcut to run as -T on all tests found.\e[0m\n"
  echo_timer "$amboso_start_time"  "Wrong test flag usage" "1"
  exit 1
  echo "UNREACHABLE"
}
fi

#Version argument is mandatory outside of:
  # purge or init mode (when not in test mode
  # init mode or FULL test mode (when in test mode)
#check arg num
# nothing else is allowed
#shift all the options
for i in $(seq 0 $(( $tot_opts - 2 )) ); do {
  shift
}
done

# $0 is now target version, at position 1 in the array ??
v_pos=1
if [[ $# -eq 1 ]] ; then {
  query="${!v_pos}"
} else {
  query=""
}
fi

if [[ $quiet_flag -eq 0 && $verbose_flag -gt 1 ]]; then { #WIP
    echo -e "\033[1;35m[VERB]    SYNCPOINT: shifted args, query was: ( $query ).\e[0m" >&2
}
fi

tot_left_args=$(( $# ))
if [[ $tot_left_args -gt 1 ]]; then {
  echo -e "\n\033[1;31m[ERROR]    Unknown argument: "$2" (ignoring other $(($tot_left_args-1)) args).\e[0m\n"
  usage
  echo_timer "$amboso_start_time"  "Unknown arg [$2]" "1"
  exit 1
}
fi

#If we don't have init or purge flag, we bail on a missing version argument
if [[ $tot_left_args -lt 1 && $purge_flag -eq 0 && $init_flag -eq 0 && $test_mode_flag -eq 0 ]]; then {
  app "$(echo_node silence_check missing_query)"
  app "$(echo_node missing_query end_node)"
  end_digraph
  echo -e "\033[1;31m[ERROR]    Missing query.\e[0m\n"
  echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
  echo_timer "$amboso_start_time"  "Missing query" "1"
  exit 1
} elif [[ $tot_left_args -lt 1 && $test_mod_flag -gt 0 ]] ; then {
  app "$(echo_node silence_check missing_test_query)"
  app "$(echo_node missing_test_query end_node)"
  end_digraph
  #If in test mode, we still whine about a target test
  echo -e "\033[1;31m[ERROR]    Missing test query.\e[0m\n"
  echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
  echo "can we do init/purge?"
}
fi
#Check if we are doing a test
if [[ $test_mode_flag -gt 0 ]]; then {
  app "$(echo_node recursion_lt_3 doing_test)"
  if [[ $quiet_flag -eq 0 && $verbose_flag -gt 1 ]]; then { #WIP
      echo -e "\033[1;35m[VERB]    Test mode (-T was on).\e[0m" >&2
      [[ $smalltest_mode_flag -gt 0 ]] && echo -e "\033[1;35m[VERB]    (-t was on).\e[0m" >&2
      echo_tests_info "$kazoj_dir" >&2
  }
  fi
  test_name=""
  test_type=""
  test_path=""
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Checking if query $query is a testcase.\e[0m" >&2
  for i in $(seq 0 $(($count_tests_names-1))); do {
    current_item="${read_tests_files[$i]}"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Checking case ($i/$count_tests_names): $current_item\e[0m" >&2
    #echo "checking $current_item"
    if [[ $query = $current_item ]]; then {
      test_type="casetest"
      test_name="$query"
      test_path="$kazoj_dir/$cases_dir/${read_tests_files[$i]}"
      break; #done looking
    }
    fi
  }
  done
  if [[ -z $test_name ]] ; then {
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Checking if query $query is a error testcase.\e[0m" >&2
    for i in $(seq 0 $(($count_errortests_names-1))); do {
      current_item="${read_errortests_files[$i]}"
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Checking error case ($i/$count_errortests_names): $current_item\e[0m" >&2
      #echo "checking $current_item"
      if [[ $query = $current_item ]] ; then {
	test_type="errortest"
	test_name="$query"
	test_path="$kazoj_dir/$errors_dir/${read_errortests_files[$i]}"
	break; #done looking
      }
      fi
    }
    done
  }
  fi

  if [[ $quiet_flag -eq 0 ]]; then { #WIP
      echo -e "\033[0;34m[TEST]    Expected:\n\n    type:  $test_type\n\n    name:  $test_name\n    path:  $test_path\n\e[0m" >&2
  }
  fi

  if [[ -z $test_path ]]; then {
    if [[ $quiet_flag -eq 0 ]] ; then {
      flaginit=""
      flagbuild=""
      [[ $build_flag -gt 0 ]] && flagbuild="b"
      [[ $init_flag -gt 0 ]] && flaginit="t"
      echo -e "\033[0;35m[VERB]    Test path was empty but we have [-$flagbuild$flaginit].\e[0m" >&2
    }
    fi
    if [[ -z $test_path && -z $query ]] ; then {
      [[ $quiet_flag -eq 0 ]] && echo -e "\033[0;35m[VERB]    testpath was empty, query was empty. Should quit.\e[0m" >&2
      keep_run_txt=""
      if [[ $init_flag -gt 0 ]] ; then {
	keep_run_txt="[INIT]"
       	echo -e "\033[1;33m[TEST]    ( \"empty\"[$query] ) is not a supported tag. $keep_run_txt.\e[0m" >&2
  	echo_timer "$amboso_start_time"  "Empty test query" "1"
        exit 1
      }
      fi
      echo -e "\033[0;35m[VERB]    UNREACHABLE.\e[0m"
      exit 1
    } elif [[ -z $test_path && ! -z $query ]] ; then {
      [[ $quiet_flag -eq 0 ]] && echo -e "\033[0;35m[VERB]    testpath was empty, query was not empty: ( $query ).\e[0m" >&2
      keep_run_txt=""
      if [[ $init_flag -gt 0 ]] ; then {
        keep_run_txt="[INIT]"
	echo -e "\033[1;33m[TEST]    ( $query ) is not a supported tag, we quit at this point. $keep_run_txt.\e[0m" >&2
  	echo_timer "$amboso_start_time"  "Unsupported test query [$query]" "3"
	exit 0
      }
      fi
      [[ $build_flag -gt 0 ]] && keep_run_txt="[BUILD]" && echo -e "\033[1;33m[TEST]    ( $query ) is not a supported tag, but we continue to $keep_run_txt.\e[0m" >&2
    } else {
      [[ $verbose_flag -gt 0 || $quiet_flag -eq 0 ]] && echo -e "\033[0;33m[TEST] expected:\n  $test_type\n\n  name: $test_name\n  path: $test_path\e[0m"# >&2
      echo -e "\033[0;32m[TEST]    target: ( $test_path ).\e[0m\n"
    }
    fi
  } elif [[ -z $test_path && -z $query ]] ; then {
    #Panic
    echo -e "\033[1;31m[ERROR]    ( $test_name : at  $test_path ) is not a supported test.\e[0m\n"
    echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
    echo_timer "$amboso_start_time"  "Unsupported test name [$test_name] at [$test_path]" "1"
    exit 1
  }
  fi

  relative_testpath="$test_path"

  if [[ $build_flag -gt 0 ]] ; then {
    echo -e "\033[0;34m[TEST]    \"-b\" is set, Recording: ( $relative_testpath ).\e[0m" >&2
    #record_test "$relative_testpath"
  } elif [[ $delete_flag -gt 0 ]] ; then {
    :
    #echo -e "\033[0;34m[TEST]    \"-d\" is set, Deleting: ( $relative_testpath ).\e[0m" >&2
    #delete_test "$relative_testpath"
  } elif [[ $init_flag -gt 0 ]] ; then {
    #echo "UNREACHABLE." && exit 1
    echo -e "\033[0;34m[TEST]    \"-i\" is set, Recording ALL: ( $relative_testpath ).\e[0m"
    echo -e "\033[1;33m[DEBUG]    ( $tot_tests ) total tests ready.\e[0m" >&2
    for i in $(seq 0 $(($tot_tests-1))); do {
      TEST="${supported_tests[$i]}"
      verb=""
      quietm=""
      showtimem=""
      [[ $show_time_flag -gt 0 ]] && showtimem="w"
      [[ $quiet_flag -gt 0 ]] && quietm="q" #We make sure to pass on eventual quiet flag mode to the subcalls
      [[ $verbose_flag -gt 0 ]] && verb="V" && echo -e "\n[TEST]    Recording ALL: ( $(($i+1)) / $tot_tests ) ( $TEST )" >&2
      echo -e "\033[1;35m[TEST]    Running:\e[0m    \033[1;34m\"$prog_name -K $kazoj_dir -D $scripts_dir -bT$quietm$verb$showtimem $TEST 2>/dev/null \"\e[0m"
      start_t=`date +%s.%N`
      ( "$prog_name" -W "$amboso_start_time" -K "$kazoj_dir" -D "$scripts_dir" -b"$quietm""$verb""$showtimem"T "$TEST" 2>/dev/null ; exit "$?")
      record_res="$?"
      if [[ $record_res -eq 69 ]]; then {
	echo -e "\033[1;31m[PANIC]    Unsupported: a test call returned 69. Will do the same.\e[0m\n" &&
    	echo_timer "$amboso_start_time"  "Record Test call returned 69" "1"
	exit 69
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
      echo -e "\n[TEST]    took $runtime s ( $TEST )" >&2
    }
    done
    #init_all_tests "$relative_testpath"
  } elif [[ $purge_flag -gt 0 ]] ; then {
    :
    #echo "[TEST]    Deleting ALL: ( $relative_testpath )."
    #purge_all_tests "$relative_testpath"
  }
  fi
  if [[ -z $relative_testpath && $init_flag -eq 0 ]] ; then {
    #Exit 0 as intended behaviour FIXME
    echo -e "\033[1;31m[TEST]    Can't proceed further with no valid target path, query was ( $query ).\e[0m"
    echo -e "\033[1;31m[TEST]    Supported tests:\e[0m"
    echo_tests_info "$kazoj_dir"
    echo -e "\033[1;31m[TEST]    Quitting.\e[0m"
    echo_timer "$amboso_start_time"  "Invalid target path [$relative_testpath]" "1"
    exit 1
  }
  fi
  if [[ -z $relative_testpath && $init_flag -eq 1 && ! -z $query ]] ; then {
    #Exit 0 as intended behaviour FIXME
    echo -e "\033[1;31m[ERROR]    Can't proceed even with -i flag, with no testpath. ( p: $relative_testpath ) can't be be ( q: $query ).\e[0m"
    echo_timer "$amboso_start_time"  "Invalid target path (-i) [$relative_testpath]" "1"
    exit 0
  }
  fi
  if [[ -z $relative_testpath && $init_flag -eq 1 && -z $query ]] ; then {
    echo -e "\033[1;31m[ERROR]    Can't proceed with no query.  ( q: $query, p: $relative_testpath ).\e[0m"
    echo_timer "$amboso_start_time"  "Empty test query [$query]" "1"
    exit 1
  }
  fi
  run_tmp_out="$(mktemp)"
  run_tmp_escout="$(mktemp)"
  run_tmp_err="$(mktemp)"
  run_tmp_escerr="$(mktemp)"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[TEST]    Created tempfiles.\e[0m" >&2
  echo -e "\033[0;36m[TEST]    Running:\e[0m    \033[1;35m\"$relative_testpath\"\e[0m"
  run_test "$relative_testpath" >>"$run_tmp_out" 2>>"$run_tmp_err"
  ran_res="$?"

  if [[ $ran_res -eq 69 ]] ; then {
    echo -e "\033[1;31m[WARN]    Test call returned 69, we clean tmpfiles and follow suit.\e[0m"
    #Delete tmpfiles
    rm -f "$run_tmp_out" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_out). Why?\e[0m\n"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_out".\e[0m" >&2
    rm -f "$run_tmp_err" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_err). Why?\e[0m\n"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_err".\e[0m" >&2
    rm -f "$run_tmp_escout" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_escout). Why?\n"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_escout".\e[0m" >&2
    rm -f "$run_tmp_escerr" || echo "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_escerr). Why?\n"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_escerr".\e[0m" >&2
    echo -e "\033[1;31m[PANIC]    Quitting with 69.\e[0m"
    echo_timer "$amboso_start_time"  "Test run ended with 69" "1"
    exit 69
  }
  fi
  #echo "r: $ran_res" >> "$run_tmp_out"
  escape_colorcodes_tee "$run_tmp_out" "$run_tmp_escout"
  escape_colorcodes_tee "$run_tmp_err" "$run_tmp_escerr"
  if [[ $build_flag -gt 0 ]] ; then {
    cp "$run_tmp_escout" "$relative_testpath.stdout" || echo -e "Failed replacing stdout with new file."
    cp "$run_tmp_escerr" "$relative_testpath.stderr" || echo -e "Failed replacing stderr with new file."
  } else {
    [[ $quiet_flag -eq 0 || $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[TEST]    Won't record, no [-b].\e[0m\n"
  }
  fi
  rm -f "$run_tmp_out" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_out). Why?\e[0m\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_out".\e[0m" >&2
  rm -f "$run_tmp_err" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_err). Why?\e[0m\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_err".\e[0m" >&2
  #Testing diff for escaped stdout
  ( diff "$run_tmp_escout" "$relative_testpath".stdout ) 2>/dev/null 1>&2
  diff_res="$?"
  out_res=""
  if [[ "$diff_res" -eq 0 ]]; then {
    out_res="pass"
    if [[ ! -z "$run_tmp_escout" && ! -z "$relative_testpath.stdout" ]]; then {
      #This one doesn't go on stderr since we still want it in recursive calls:
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Pass, both outputs are not empty.\e[0m"
    } elif [[ -z "$run_tmp_escout" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, current stdout is empty. Is that expected?\e[0m">&2
    } elif [[ -z "$relative_testpath.stdout" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, registered stdout is empty. Is that expected?\e[0m" >&2
    }
    fi
    if [[ $verbose_flag -gt 0 && $quiet_flag -eq 0 ]]; then {
      echo -e "\n\033[0;32m[TEST]    (stdout) Expected:\e[0m"
      cat "$relative_testpath.stdout"
      echo -e "\n\033[0;32m[TEST]    (stdout) Found:\e[0m"
      cat "$run_tmp_escout"
    }
    fi
  } else {
    out_res="fail"
    if [[ $quiet_flag -eq 0 ]]; then {
      echo -e "\n\033[1;31m[TEST]    (stdout) Expected:\e[0m"
      cat "$relative_testpath.stdout"
      echo -e "\n\033[1;31m[TEST]    (stdout) Found:\e[0m"
      cat "$run_tmp_escout"
    }
    fi
    echo -e "\033[1;31m[TEST]    Failed: stdout changed.\e[0m"
    #cat "$run_tmp_escout"
  }
  fi
  rm -f "$run_tmp_escout" || echo -e "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_escout). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_escout".\e[0m" >&2
  #Testing diff for escaped stderr
  ( diff "$run_tmp_escerr" "$relative_testpath".stderr ) 2>/dev/null 1>&2
  diff_res="$?"
  if [[ "$diff_res" -eq 0 ]]; then {
    err_res="pass"
    if [[ ! -z "$run_tmp_escerr" && ! -z "$relative_testpath.stderr" ]]; then {
      #This one doesn't go on stderr since we still want it in recursive calls:
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Pass, both stderrs are not empty.\e[0m"
    } elif [[ -z "$run_tmp_escerr" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, current run stderr is empty. Is that expected?\e[0m">&2
    } elif [[ -z "$relative_testpath.stderr" ]]; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[TEST]    Pass, registered stderr is empty. Is that expected?\e[0m" >&2
    }
    fi
    if [[ $verbose_flag -gt 0 && $quiet_flag -eq 0 ]]; then {
      echo -e "\n\033[0;32m[TEST]    (stderr) Expected:\e[0m"
      cat "$relative_testpath.stderr"
      echo -e "\n\033[0;32m[TEST]    (stderr) Found:\e[0m"
      cat "$run_tmp_escerr"
    }
    fi
    #cat "$run_tmp_escerr"
  } else {
    err_res="fail"
    if [[ $quiet_flag -eq 0 ]]; then {
      echo -e "\n\033[1;31m[TEST]    (stderr) Expected:\e[0m"
      cat "$relative_testpath.stderr"
      echo -e "\n\033[1;31m[TEST]    (stderr) Found:\e[0m"
      cat "$run_tmp_escerr"
    }
    fi
    echo -e "\033[1;31m[TEST]    Failed: stderr changed.\e[0m"
    #cat "$run_tmp_escerr"
  }
  fi
  rm -f "$run_tmp_escerr" || echo "\033[1;31m[ERROR]    Failed removing tmpfile ($run_tmp_escerr). Why?\n"
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[TEST]    Removed tempfile "$run_tmp_escerr".\e[0m" >&2
  if [[ $build_flag -gt 0 ]] ; then {
    #We simulate success since we're recording
    echo -e "\033[1;33m[TEST]    Phony pass (recording).\e[0m"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m    (out: $out_res)\e[0m"
    [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m    (err: $err_res)\e[0m"
    echo_timer "$amboso_start_time"  "Phony test pass" "3"
    exit 0 #We return earlier
  } elif [[ $out_res = "pass" && $err_res = "pass" ]]; then {
    echo -e "\033[1;32m[TEST]    Passed.\e[0m"
    echo_timer "$amboso_start_time"  "Test pass" "2"
    exit 0 #We return earlier
  } elif [[ $out_res = "fail" ]] ; then {
   : #echo "failed" #We echoed before
  } elif [[ $err_res = "fail" ]] ; then {
   : #echo "failed" #We echoed before
  } else {
    echo -e "\033[1;31m[ERROR]    Unexpected values (o:$out_res/e:$err_res) should be either pass or fail.\e[0m. How?"
  }
  fi
  echo_timer "$amboso_start_time"  "Test fail" "1"
  exit 1
}
fi
#End of test mode block

#We expect $scripts_dir to end with /
version=""
for i in $(seq 0 $(($tot_vers-1))); do
  [[ $query = ${supported_versions[$i]} ]] && version="$query" && script_path=""$scripts_dir"v"$version""
done

if [[ -z $version ]]; then {
  #We only freak out if we don't have test_mode, purge or init flags on
  if [[ $test_mode_flag -eq 0 && $purge_flag -eq 0 && $init_flag -eq 0 ]] ; then {
    app "$(echo_node silence_check query_invalid)"
    app "$(echo_node query_invalid end_node)"
    end_digraph
    echo -e "\033[1;31m[ERROR]    ( $query ) is not a supported tag.\e[0m\n"
    echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
    echo_timer "$amboso_start_time"  "Invalid query [$query]" "1"
    exit 1
  } elif [[ ! -z $query && $test_mode_flag -gt 0 ]] ; then { #If we're in test mode, gently tell the user that the version is not supported
    keep_run_txt=""
    [[ $init_flag -gt 0 ]] && keep_run_txt="$mode_txt[INIT]"
    [[ $purge_flag -gt 0 ]] && keep_run_txt="$mode_txt[PURGE]"
    echo -e "\n\033[1;33m[DEBUG]    ( $query ) is not a supported test. $keep_run_txt.\e[0m" >&2
    echo_timer "$amboso_start_time"  "Invalid test query [$query]" "1"
    exit 1;
  }
  fi
}
fi
#We now should have a valid $version value, outside of purge or init mode

if [[ $gen_C_headers_set -gt 0 && $gen_C_headers_flag -gt 0 ]]; then {
    echo -e "\033[1;36m[AMBOSO]    Generate C header for [$version].\e[0m" >&2
    gen_C_headers $gen_C_headers_destdir $version $exec_entrypoint
}
fi

has_makefile=0
if [[ $version > $makefile_version || $version = $makefile_version ]] ; then
  has_makefile=1
fi

can_automake=0
if [[ $version > $use_autoconf_version || $version = $use_autoconf_version ]] ; then
  can_automake=1
fi

#If we can't find the file we may try to build it
if [[ ! -f "$script_path/$exec_entrypoint" && ! -z $version ]] ; then {
  if [[ $init_flag -eq 0 ]] ; then {
    app "$(echo_node silence_check query_success_not_ready)"
  }
  fi
  echo -e "\n\033[1;33m[QUERY]    ( $version ) binary not found in ( $script_path ).\e[0m" #>&2
  if [[ $verbose_flag -gt 0 ]] ; then {
	  echo_tag_info $version
  }
  fi
  if [[ ! $build_flag -gt 0 ]] ; then { #We exit here if we don't want to try building and we're not going to purge
    echo -e "\033[0;33m[DEBUG]    To try building, run with -b flag\e[0m\n" >&2
    if [[ ! $purge_flag -gt 0 ]] ; then {
     app "$(echo_node query_success_not_ready end_node)"
     end_digraph
     echo_timer "$amboso_start_time"  "No build flag" "1"
     exit 1 # quit if we're not purging
    }
    fi
  } else {
    if [[ ! -d "$script_path" ]] ; then
      echo -e "\033[1;31m[ERROR]    '$script_path' is not a valid directory.\n    Check your supported versions for details on ( $version ).\e[0m\n" >&2
      app "$(echo_node query_success_not_ready end_node)"
      end_digraph
      echo_timer "$amboso_start_time"  "Invalid path [$script_path]" "1"
      exit 1
    fi
    #we try to build
    tool_txt="single file gcc"
    app "$(echo_node query_success_not_ready building)"
    if [[ $has_makefile -gt 0 ]]; then { #Make mode
      tool_txt="make"
      if [[ $can_automake -gt 0 ]] ; then { #We support automake by doing autoreconf and ./configure before running make.
      	tool_txt="automake"
        echo -e "\033[0;33m[MODE]    target ( $version ) >= ( $use_autoconf_version ), can autoconf.\e[0m" >&2
	autoreconf
	./configure
        echo -e "\033[0;32m[INFO]    Done 'autoreconf' and './configure'.\e[0m" >&2
      }
      fi
      echo -e "\033[0;33m[MODE]    target ( $version ) >= ( $makefile_version ), has Makefile.\e[0m" >&2
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Building ( $version ), using make.\e[0m" >&2
      curr_dir=$(realpath .)
      start_t=`date +%s.%N`
      if [[ $git_mode_flag -eq 0 && $base_mode_flag -eq 1 ]] ; then { #Building in base mode, we cd into target directory before make
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[BUILD]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
        cd $script_path; make >&2
        comp_res=$?
      } else { #Building in git mode, we checkout the tag and move the binary after the build
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;34m[BUILD]    Running in git mode, checking out ( $version ).\e[0m" #>&2
        git checkout "$version" 2>/dev/null #Repo goes back to tagged state
        checkout_res=$?
        if [[ $checkout_res -gt 0 ]] ; then { #Checkout failed, we don't build and we set comp_res
          echo -e "\033[1;31m[ERROR]    Checkout of ( $version ) failed, this stego.lock tag does not work for the repo.\e[0m" #>&2
          comp_res=1
        } else { #Checkout successful, we build
          git submodule update --init --recursive #We set all submodules to commit state
          make >&2 #Never try to build if checkout fails
          comp_res=$?
          #Output is expected to be in the main dir:
          if [[ ! -e ./$exec_entrypoint ]] ; then {
            echo -e "\033[1;31m[ERROR]    $exec_entrypoint not found at ($pwd).\e[0m" #>&2
          } else {
            mv "./$exec_entrypoint" "$script_path" #All files generated during the build should be ignored by the repo, to avoid conflict when checking out
            [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Moved $exec_entrypoint to $script_path.\e[0m" #>&2
          }
          fi
          git switch - #We get back to starting repo state
          switch_res="$?"
          if [[ $switch_res -gt 0 ]]; then {
	    echo -e "\n\033[1;31m[ERROR]    Can't finish checking out ($version).\n    You may have a dirty index and may need to run \033[1;35\"git restore .\"\e[0m.\n Abort.\n"
            echo_timer "$amboso_start_time"  "Failed checkout" "1"
	    exit 1
    	  }
	  fi
          git submodule update --init --recursive #We set all submodules to commit state
          [[ $quiet_flag -eq 0 ]] && echo -e "\033[0;32m[BUILD]    Switched back to starting commit.\e[0m"
        }
        fi
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
      cd "$curr_dir"
    } else { #Straight gcc mode
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[MODE]    target ( $version ) < ( $makefile_version ), single file build with gcc.\e[0m" >&2
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Building ( $version ), using gcc call.\e[0m" >&2
      #echo "" >&2 #new line for error output
      if [[ -z $source_name ]]; then {
	echo -e "\n\033[1;31m[WTF-ERROR]    Missing source file name. ( $version ).\e[0m\n"
	usage
        echo_timer "$amboso_start_time"  "Missing source name for [$version]" "1"
	exit 1
      }
      fi
      [[ $pack_flag -gt 0 ]] && echo -e "\n\033[1;33m[PACK]    -z is not supported for ($tool_txt). TAG < ($makefile_version).\n\n    \033[1;35Current: ($version @ $source_name).\e[0m\n"

      start_t=`date +%s.%N`
      if [[ $git_mode_flag -eq 0 ]] ; then { #Building in base mode, we cd into target directory before make
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[BUILD]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
        gcc "$script_path"/"$source_name" -o "$script_path"/"$exec_entrypoint" -lm 2>&2
        comp_res=$?
      } else { #Building in git mode, we checkout the tag and move the binary after the build
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;34m[BUILD]    Running in git mode, checking out ( $version ).\e[0m" #>&2
        git checkout "$version" 2>/dev/null #Repo goes back to tagged state
        checkout_res=$?
        if [[ $checkout_res -gt 0 ]] ; then { #Checkout failed, we set comp_res and don't build
          echo -e "\033[1;31m[ERROR]    Checkout of ( $version ) failed, stego.lock may be listing a tag name not on the repo.\e[0m"
          comp_res=1
        } else {
          git submodule update --init --recursive 2>/dev/null#We set all submodules to commit state
          gcc "./$source_name" -o "$script_path"/"$exec_entrypoint" -lm 2>&2 #Never try to build if checkout fails
          comp_res=$?
          #All files generated during the build should be ignored by the repo, to avoid conflict when checking out
          git switch - 2>/dev/null #We get back to starting repo state
          switch_res="$?"
          if [[ $switch_res -gt 0 ]]; then {
	    echo -e "\n\033[1;31m[ERROR]    Can't finish checking out ($version). Abort."
            echo_timer "$amboso_start_time"  "Failed checkout for [$version]" "1"
	    exit 1
          }
	  fi
          [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[BUILD]    Switched back to starting commit.\e[0m" >&2
        }
        fi
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
    }
    fi
    #Check compilation result
    if [[ $comp_res -eq 0 ]] ; then
      echo -e "\033[1;32m[BUILD]    Done Building ( $version ) , took $runtime seconds, using ( $tool_txt ).\e[0m"
      app "$(echo_node building build_success)"
    else
      echo -e "\033[1;31m[ERROR]    Build for ( $version ) failed, quitting.\e[0m\n" >&2
      app "$(echo_node building build_fail)"
      app "$(echo_node build_fail end_node)"
      end_digraph
      echo_timer "$amboso_start_time"  "Failed build for [$version]" "1"
      exit 1
    fi

  }
  fi

} elif [[ ! -z $version ]] ; then { #Binary was present, we notify if we were running with build flag
  if [[ $init_flag -eq 0 ]] ; then {
    app "$(echo_node silence_check query_success_ready)"
  } else {
    app "$(echo_node doing_init query_success_ready)"
  }
  fi
  echo -e "\n\033[1;32m[QUERY]    ( $version ) binary is ready at ( $script_path ) .\e[0m\n" >&2
  if [[ $verbose_flag -gt 0 ]] ; then {
	  echo_tag_info $version
  }
  fi
  if [[ $build_flag -gt 0 ]] ; then {
    echo -e "\033[0;33m[BUILD]    Found binary for ( $version ), won't build.\e[0m" >&2
    app "$(echo_node query_success_ready build_success)"

  }
  fi
  #Check if we're packing the ready version
  if [[ $pack_flag -gt 0 ]] ; then {
    #We just leverage make pack and assume it's ready to roll
    echo -e "\033[0;35m[PACK]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
    make pack
    pack_res=$?
    if [[ $pack_res -gt 0 ]] ; then { #make pack failed
      echo -e "\033[1;31m[PACK]    Packing ($version) in base mode, failed.\n    Expected source at ($script_path).\e[0m" #>&2
    } else {
      echo -e "\033[1;32m[PACK]    Packed ($version):\n    from  ($script_path)\e[0m" #>&2
    }
    fi
  }
  fi

} elif [[ ! -z $query ]] ; then {
  app "$(echo_node silence_check query_invalid)"
  echo -e "\033[1;31m[QUERY]    ( $query ) invalid query, run with -V to see more.\e[0m"
  if [[ $verbose_flag -gt 0 ]] ; then {
	  echo_tag_info $version
  }
  fi
}
fi

#We check the run flag to run the binary
if [[ ! -z $version && $run_flag -eq 1 && -x $script_path/$exec_entrypoint ]] ; then {
  if [[ $build_flag -gt 0 && $comp_res -eq 0 ]]; then { #The second condition is needed to catch running a freshly built tag
    app "$(echo_node build_success running)"
  } else {
    app "$(echo_node query_success_ready running)"
  }
  fi
  echo -e "\n\033[0;32m[DEBUG]    Running script $script_path/$exec_entrypoint\e[0m"
  #echo -n "."
  #sleep 1
  #echo ""
  ( cd "$script_path" ; ./"$exec_entrypoint" )
} elif [[ ! -z $version && $run_flag -eq 0  ]] ; then {
  echo -e "\033[0;33m[DEBUG]    Running without -r flag, won't run.\e[0m" >&2
} elif [[ -z $version && $run_flag -gt 0 ]] ; then {
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[DEBUG]    Running with -r but requested an empty tag ( $version )!\e[0m" >&2
}
fi

#Check if we are deleting and exiting early
#We skipped first deletion pass if purge mode is requested, since we will enter here later
if [[ $delete_flag -gt 0 && $purge_flag -eq 0 ]] ; then {
  if [[ $run_flag -gt 0 ]] ; then {
    app "$(echo_node running deleting)"
  } elif [[ $build_flag -gt 0 ]] ; then {
    app "$(echo_node build_success deleting)"
  } else {
    app "$(echo_node query_success_ready deleting)"
  }
  fi
    clean_res=1
  if [[ $has_makeclean -gt 0 && $base_mode_flag -gt 0 ]] ; then { #Running in git mode skips make clean
    tool_txt="make clean"
    has_bin=0
    curr_dir=$(realpath .)
    delete_path="$scripts_dir""v""$version"
      if [[ ! -d $delete_path ]] ; then {
        echo -e "\033[1;31m[ERROR]    '$delete_path' is not a valid directory.\n    Check your supported versions for details on ( $version ).\e[0m\n" #>&2
      } elif [[ -x $scripts_dir/v$version/$exec_entrypoint ]] ; then { #Executable exists
        has_bin=1 && echo -e "\033[0;33m[DELETE]   ( $version ) has an executable.\e[0m\n" >&2
        cd "$delete_path"; make clean 2>/dev/null #1>&2
        clean_res=$?
        cd "$curr_dir"
        echo_timer "$amboso_start_time"  "Did delete, res was [$clean_res]" "3"
        exit "$clean_res"
      } else {
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;31m[DELETE]   ( $versions ) does not have an executable at ( $delete_path ).\e[0m\n" # >&2
        app "$(echo_node deleting no_target_error)"
        app "$(echo_node no_target_error end_node)"
        end_digraph
        echo_timer "$amboso_start_time"  "Nothing to delete" "1"
        exit 1
      }
      fi
  } else { #Doesn't have Makefile, build method 2. Running in git mode also skips using make clean
    tool_txt="rm"
    has_bin=0
    if [[ -x $scripts_dir"/v$version"/"$exec_entrypoint" ]] ; then {
      has_bin=1 && [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[DELETE]    ( $version ) has an executable.\e[0m" >&2
    }
    fi
    rm $(realpath "$scripts_dir"/"v$version/$exec_entrypoint") #2>/dev/null
    clean_res=$?
    if [[ $clean_res -eq 0 ]] ; then {
      echo -e "\033[0;32m[DELETE]    Success on ( $version ).\e[0m"
      app "$(echo_node deleting delete_success)"
      app "$(echo_node delete_success end_node)"
      end_digraph
    } else {
      echo -e "\033[0;31m[DELETE]    Failure on ( $version ).\e[0m"
      app "$(echo_node deleting delete_fail)"
      app "$(echo_node delete_fail end_node)"
      end_digraph
    }
    fi
    echo_timer "$amboso_start_time"  "Did delete, res was [$clean_res]" "3"
    exit "$clean_res"
  }
  fi
}
fi

#Check if we are purging
if [[ purge_flag -gt 0 ]]; then
  if [[ $run_flag -gt 0 ]] ; then {
    app "$(echo_node running purging)"
  } elif [[ $build_flag -gt 0 ]] ; then {
    app "$(echo_node build_success purging)"
  } else {
    app "$(echo_node query_success_ready purging)"
  }
  fi
  #echo "" >&2 #This newline can be redirected when doing recursion for init mode
  tot_removed=0
  tool_txt="rm"
  has_bin=0
  for i in $(seq 0 $(($tot_vers-1)) ); do
    clean_res=1
    has_makeclean=0
    purge_vers=${supported_versions[$i]}
    if [[ -x $scripts_dir/v$purge_vers/$exec_entrypoint ]] ; then {
      has_bin=1 #&& [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[DELETE]    $version has an executable.\e[0m\n" >&2
    } else {
      continue; #We just skip the version
    }
    fi
    if [[ $purge_vers > "$makefile_version" || $purge_vers = "$makefile_version" ]] ; then
      [[ $git_mode_flag -eq 0 ]] && has_makeclean=1 && tool_txt="make clean" #We never use make clean for purge, if in git mode
    fi

    ## Rerun with -d
    verb=""
    gitm=""
    basem=""
    quietm=""
    silentm=""
    packm=""
    ignore_gitcheck=""
    showtimem=""
    [[ $show_time_flag -gt 0 ]] && showtimem="w"
    [[ $ignore_git_check_flag -gt 0 ]] && ignore_gitcheck="X"
    [[ $pack_flag -gt 0 ]] && packm="z"
    [[ $silent_flag -gt 0 ]] && silentm="s"
    [[ $verbose_flag -gt 0 ]] && verb="V" && echo -e "\n[PURGE]    Trying to delete ( $purge_vers ) ( $(($i+1)) / $tot_vers )" >&2
    [[ $base_mode_flag -gt 0 ]] && basem="B" #We make sure to pass on eventual base mode to the subcalls
    [[ $git_mode_flag -gt 0 ]] && gitm="g" #We make sure to pass on eventual git mode to the subcalls
    [[ $quiet_flag -gt 0 ]] && quietm="q" #We make sure to pass on eventual quiet flag mode to the subcalls
    if [[ $quiet_flag -eq 0 ]] ; then {
      echo -e "\033[1;35m[PURGE]    Running \"$(basename "$prog_name") -W $amboso_start_time-M $makefile_version -S $source_name -E $exec_entrypoint -D $scripts_dir -d$verb$gitm$basem$quietm$silentm$packm$ignore_gitcheck$showtimem $purge_vers 2>/dev/null\"\e[0m"
    }
    fi
    ( $prog_name -W "$amboso_start_time" -M "$makefile_version" -S "$source_name" -E "$exec_entrypoint" -D "$scripts_dir" -d"$verb""$gitm""$basem""$quietm""$silentm""$packm""$ignore_gitcheck""$showtimem" "$purge_vers" ) 2>/dev/null
    clean_res="$?"
    #To be sure delete OP is gonna be the returning op here, we assume pack just never makes the script return, so it will always go to delete OP safely.

    #Check clean result
    if [[ $clean_res -eq 0 && $has_bin -gt 0 ]] ; then {
      #we advance the count
      tot_removed=$(($tot_removed +1))
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[PURGE]    Removed ( $purge_vers ) using ( $tool_txt ).\e[0m" >&2
    } else {
      verbose_hint=""
      [[ $verbose_flag -lt 1 ]] && verbose_hint="Run with -V to see more info."
      echo -e "\n\033[1;31m[PURGE]    Failed delete for ( $purge_vers ) binary. $verbose_hint\e[0m\n"
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;31m[PURGE]    Failed removing ( $purge_vers ) using ( $tool_txt ). $verbose_hint\e[0m" #>&2
      #try deleting again to get more output, since we discarded stderr before
      #
      #we could just pass -v to the first call if we have it on
      if [[ $verbose_flag -gt 0 ]]; then {
	echo -e "[PURGE]    Verbose flag was asserted as ($verbose_flag)." >&2
	echo -e "[PURGE]    Checking errors, running \033[1;33m$(basename "$prog_name") -dVV $purge_vers\e[0m." >&2
	("$prog_name" -W "$amboso_start_time" -M "$makefile_version" -S "$source_name" -D "$scripts_dir" -E "$exec_entrypoint" -dVV"$gitm""$basem""$ignore_gitcheck""$showtimem" "$purge_vers") #>&2
      }
      fi
    }
    fi

  done
  if [[ $tot_removed -gt 0 ]] ; then {
    echo -e "\033[0;33m[PURGE]    Purged ( $tot_removed / $tot_vers ) versions, quitting.\e[0m\n"
    app "$(echo_node purging purging_success)"
    app "$(echo_node purging_success end_node)"
  } else {
    echo -e "\n\033[0;33m[PURGE]    No binaries to purge found.\e[0m\n"
    app "$(echo_node purging purging_fail)"
    app "$(echo_node purging_fail end_node)"
  }
  fi
fi

if [[ $delete_flag -eq 0 ]]; then {
    #We need to close cfg dump
    if [[ $run_flag -gt 0 ]] ; then {
      app "$(echo_node running end_node)"
    } elif [[ $build_flag -gt 0 ]] ; then {
      app "$(echo_node build_success end_node)"
    } else {
      app "$(echo_node query_success_ready end_node)"
    }
    fi
}
fi

end_digraph
echo_timer "$amboso_start_time"  "Run" "6"
exit 0
