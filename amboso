#!/bin/bash
# Bash script to run a milestone build providing the version number.

prog_name="$0"
amboso_version="amboso version 1.0.0"

function echo_amboso_version {
  echo "$amboso_version"
}

function set_supported_versions {
  dir=$1
  [[ ! -f $dir/stego.lock ]] && echo -e "[ERROR]    Can't find \"stego.lock\" in ( $dir ).\n" && exit 1
  k=0
  j=0
  while IFS= read -r line; do
    #Skip the first four lines, reserved for header, source file and target executable names, and versions header
    [[ $j -lt 5 ]] && j=$((j+1)) && continue

    #echo "Text read from file: ( $line )"
    #echo "Text read from file, no comments: ( $( echo "$line" | cut -d '#' -f 1 ) )"
    read_versions[k]=$(echo "$line" | cut -d '#' -f 1)
    k=$((k+1))
  done < "$dir/stego.lock" 2>/dev/null
  #echo "version array size is " "${#read_versions[@]}" >&2
  count_versions="${#read_versions[@]}"
  #echo "$count_versions"
  #echo "version array contents are: ( ${read_versions[@]} )" >&2
  for i in $(seq 0 $(($count_versions-1))); do
    supported_versions[i]=${read_versions[i]}
  done
  tot_vers=${#supported_versions[@]}
}

function set_source_info {
  dir=$1
  [[ ! -f $dir/stego.lock ]] && echo -e "[ERROR]    Can't find \"stego.lock\" in ( $dir ). Try running with -D to specify the right directory.\n" && exit 1
  j=0
  k=0
  while IFS= read -r line; do
    #Skip the first line header
    [[ $j -lt 1 ]] && j=$((j+1)) && continue

    #echo "Text read from file: ( $line )"
    #echo "Text read from file, no comments: ( $( echo "$line" | cut -d '#' -f 1 ) )"
    sources_info[k]=$(echo "$line" | cut -d '#' -f 1)
    k=$((k+1))
    [[ $k -eq 3 ]] && break #we only read the first two lines
  done < "$dir/stego.lock" 2>/dev/null
  #echo "source info array size is " "${#sources_info[@]}" >&2
  count_source_infos="${#sources_info[@]}"
  #echo "$count_source_infos"
  #echo "source info array contents are: ( ${sources_info[@]} )" >&2
}

function usage {
  echo -e "Usage: $(basename $prog_name) [OPTION]... VERSION_QUERY\n"
  echo "    Query for a build version"
  echo -e "\n    $tot_vers Supported local versions:"
  for i in $(seq 0 $(($tot_vers-1))); do
    (( $i % 4 == 0)) && echo -en "\n        "
    echo -en "${supported_versions[i]}  "
  done
  echo -e "\n\n    [OPTIONS]:\n"
  echo -e "        -D TARGET_DIR        directory\n"
  echo -e "                Specifies target directory\n"
  echo -e "        -E TARGET_EXEC       executable\n"
  echo -e "                Specifies target executable name\n"
  echo -e "        -S TARGET_SOURCE       sourcename\n"
  echo -e "                Specifies sourcefile name for single file mode.\n"
  echo -e "        -M MAKEFILE_SUPPORT       tagname\n"
  echo -e "                Specifies a tag name for lowest version to support make.\n"
  echo -e "        -B        base mode\n"
  echo -e "                Uses full source builds. Not recommended.\n"
  echo -e "        -g        git mode\n"
  echo -e "                Uses git checkouts of supported tags. Enabled by default.\n"
  echo -e "        -b        build\n"
  echo -e "                Tries building the binary if it's not available.\n"
  echo -e "        -r        run\n"
  echo -e "                Specifies you want to run the milestone.\n"
  echo -e "        -i        init\n"
  echo -e "                Tries building all supported versions.\n"
  echo -e "        -p        purge\n"
  echo -e "                Removes all milestone binaries and quits.\n"
  echo -e "        -V        verbose\n"
  echo -e "                More debug output.\n"
  echo -e "        -h        help\n"
  echo -e "                Prints help info in paged format.\n"
  echo -e "        -H        help\n"
  echo -e "                Prints help message and quits.\n"
  echo -e "        -v        version\n"
  echo -e "                Prints version message and quits.\n"
}

function git_mode_check {
  is_git_repo=0
  #Check if we're inside a repo
  git rev-parse --is-inside-work-tree 2>/dev/null 1>&2
  is_git_repo="$?"
  [[ $is_git_repo -gt 0 ]] && echo -e "\n\033[1;31m[ERROR]    Not running in a git repo. Try running with -B to use base mode.\e[0m\n" && exit 1
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;34m[AMBOSO-MODE]    Running in git mode.\e[0m" >&2
}

#Prepare flag values to default value
purge_flag=0
run_flag=0 #By default we don't run the binary
build_flag=0
init_flag=0
verbose_flag=0
dir_flag=0
exec_entrypoint= #By default the value is empty
exec_was_set=0
source_name=
sourcename_was_set=0
bighelp_flag=0
smallhelp_flag=0
vers_make_flag=0
makefile_version=""
git_mode_flag=1 #By default we run in git mode
base_mode_flag=0

while getopts "M:S:E:D:BgVbpHhriv" opt; do
  case $opt in
    S )
      source_name="$OPTARG"
      sourcename_was_set=1
      ;;
    E )
      exec_entrypoint="$OPTARG"
      exec_was_set=1
      ;;
    D )
      dir_flag=1
      milestones_dir="$OPTARG"
      ;;
    M )
      vers_make_flag=1
      makefile_version="$OPTARG"
      ;;
    H )
      bighelp_flag=1
      ;;
    h )
      smallhelp_flag=1
      ;;
    B )
      base_mode_flag=1
      ;;
    g )
      git_mode_flag=1
      ;;
    V )
      verbose_flag=1
      ;;
    v )
      echo_amboso_version
      exit 0
      ;;
    p )
      purge_flag=1
      ;;
    r )
      run_flag=1
      ;;
    b )
      build_flag=1
      ;;
    i )
      init_flag=1
      ;;
    \? )
      echo "Invalid option: -$OPTARG" >&2
      usage
      exit 1
      ;;
    : )
      echo "Option -$OPTARG requires an argument." >&2
      usage
      exit 1
      ;;
  esac
tot_opts=$OPTIND
done

#We check again if basemode was requested, as the only flag checked in build stage is git_mode_flag
[[ $base_mode_flag -gt 0 ]] && git_mode_flag=0 && echo -e "\033[1;31m[AMBOSO-MODE]    Running in base mode, expecting full source builds.\e[0m" >&2
[[ $git_mode_flag -gt 0 ]] && git_mode_check #We are now sure we can quit immediately if not running in a git repo

#We always notify of missing -D argument
[[ ! $dir_flag -gt 0 ]] && milestones_dir="$(pwd)/bin/" && echo -e "\033[1;33m[DEBUG]    No -D flag, using ./bin for target dir. Run with -v to see more.\e[0m" >&2 #&& usage && exit 1

#Check if we are printing help info and exiting early
if [[ $smallhelp_flag -gt 0 ]]; then {
      "$prog_name" -H -D "$milestones_dir" | less
      exit 0
}
fi
#Check if we are printing Help info and exiting early
if [[ $bighelp_flag -gt 0 ]]; then {
      echo_amboso_version
      set_source_info "$milestones_dir"
      set_supported_versions "$milestones_dir"
      usage
      exit 0
}
fi

scripts_dir="$milestones_dir" # MUST BE SET before checking for -S and -E
set_supported_versions "$scripts_dir" # Might as well do it now

#If version for makefile support was not specified, it's read from the file (an empty value would work maybe)
if [[ -z $makefile_version ]] ; then {
  set_source_info "$milestones_dir"
  makefile_version=${sources_info[2]}
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[DEBUG]    No -F flag, reading stego.lock for target makefile support version.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -E argument if we're in verbose mode
if [[ -z $exec_entrypoint ]] ; then {
  set_source_info "$milestones_dir"
  exec_entrypoint=${sources_info[1]}
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[DEBUG]    No -E flag, reading stego.lock for target bin.\e[0m" >&2 # && usage && exit 1
}
fi

#We notify of missing -S argument if we're in verbose mode
if [[ -z $source_name ]] ; then {
  set_source_info "$milestones_dir"
  source_name=${sources_info[0]}
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;33m[DEBUG]    No -S flag, reading stego.lock for target sourcename.\e[0m" >&2 # && usage && exit 1
}
fi

#echo "" >&2

#Display needed values if in verbose mose
[[ $verbose_flag -gt 0 && ! $dir_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using target dir: ( $scripts_dir ).\e[0m" >&2
[[ $verbose_flag -gt 0 && ! $exec_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using target bin: ( $exec_entrypoint ).\e[0m" >&2
[[ $verbose_flag -gt 0 && ! $sourcename_was_set -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using source file name: ( $source_name ).\e[0m" >&2
[[ $verbose_flag -gt 0 && ! $vers_make_flag -gt 0 ]] && echo -e "\033[0;32m[INFO]    Using tag for make support: ( $makefile_version ) as first tag compiled with make.\e[0m" >&2

#Check if we are doing init
if [[ $init_flag -gt 0 ]] ; then {
  count_bins=0
  start_t_init=`date +%s.%N`
  for i in $(seq 0 $(($tot_vers-1))); do
    init_vers="${supported_versions[$i]}"
    #Build this vers
    #Init mode ALWAYS tries building, even if we have the binary already ATM
    #Save verbose flag
    verb=""
    gitm=""
    basem=""
    [[ $verbose_flag -gt 0 ]] && verb="V" && echo -e "\n[INIT]    Trying to build ( $init_vers ) ( $(($i+1)) / $tot_vers )" >&2
    [[ $base_mode_flag -gt 0 ]] && basem="B" #We make sure to pass on eventual base mode to the subcalls
    [[ $git_mode_flag -gt 0 ]] && gitm="g" #We make sure to pass on eventual git mode to the subcalls
    #First pass sets the verbose flag but redirects stderr to /dev/null
    $prog_name -M "$makefile_version" -S "$source_name" -E "$exec_entrypoint" -D "$scripts_dir" -b"$verb""$gitm""$basem" "$init_vers" 2>/dev/null
    if [[ $? -eq 0 ]] ; then {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[INIT]    $init_vers binary ready.\e[0m" >&2
      count_bins=$(($count_bins +1))
    } else {
      verbose_hint=""
      [[ $verbose_flag -lt 1 ]] && verbose_hint="Run with -v to see more info."
      echo -e "\n\033[1;31m[INIT]    Failed build for $init_vers binary. $verbose_hint\e[0m\n"
      #try building again to get more output, since we discarded stderr before
      #
      #we could just pass -v to the first call if we have it on
      if [[ $verbose_flag -gt 0 ]]; then {
	echo -e "[INIT]    Checking errors, running \033[1;33m$(basename "$prog_name") -bV $init_vers\e[0m." >&2
	("$prog_name" -M "$makefile_version" -S "$source_name" -D "$scripts_dir" -E "$exec_entrypoint" -bV"$gitm""$basem" "$init_vers") >&2
      }
      fi
    }
    fi
  done
  end_t_init=`date +%s.%N`
  runtime_init=$( echo "$end_t_init - $start_t_init" | bc -l )
  display_zero=$(echo $runtime_init | cut -d '.' -f 1)
  if [[ -z $display_zero ]]; then {
    display_zero="0"
  } else {
    display_zero=""
  }
  fi
  echo -e "[INIT]    Took $display_zero$runtime_init seconds, ( $count_bins / $tot_vers ) binaries ready."
  #We don't quit after the full build.
  #exit 0
}
fi

#Version argument is mandatory outside of purge or init mode
#check arg num
# nothing else is allowed
#shift all the options
for i in $(seq 0 $(( $tot_opts - 2 )) ); do
  shift
done

# $0 is now target version, at position 1 in the array ??
v_pos=1
queried_version="${!v_pos}"

tot_left_args=$(( $# ))
if [[ $tot_left_args -gt 1 ]]; then {
  echo -e "\n\033[1;31m[ERROR]    Unknown argument: "$2".\e[0m\n"
  usage
  exit 1
}
fi

#If we don't have init or purge flag, we bail on a missing version argument
if [[ $tot_left_args -lt 1 && $purge_flag -eq 0 && $init_flag -eq 0 ]]; then {
  echo -e "\033[1;31m[ERROR]    Missing version query.\e[0m\n"
  echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
  exit 1
}
fi

#We expect $scripts_dir to end with /
version=""
for i in $(seq 0 $(($tot_vers-1))); do
  [[ $queried_version = ${supported_versions[i]} ]] && version="$queried_version" && script_path=""$scripts_dir"v"$version""
done

if [[ -z $version ]]; then {
  #We only freak out if we don't have purge or init flags on
  if [[ $purge_flag -eq 0 && $init_flag -eq 0 ]] ; then {
    echo -e "\033[1;31m[ERROR]    ( $queried_version ) is not a valid version.\e[0m\n"
    echo -e "\033[1;33m           Run with -h for help.\e[0m\n"
    exit 1
  } elif [[ ! -z $queried_version ]] ; then { #We gently tell the user that the version is not supported
    keep_run_txt=""
    [[ $init_flag -gt 0 ]] && keep_run_txt="$mode_txt[INIT]"
    [[ $purge_flag -gt 0 ]] && keep_run_txt="$mode_txt[PURGE]"
    echo -e "\n\033[1;33m[DEBUG]    ( $queried_version ) is not a supported version, but we keep running to do $keep_run_txt.\e[0m" >&2
  }
  fi
  [[ $purge_flag -eq 0 && $init_flag -eq 0 ]] && echo -e "\n\033[1;31m[ERROR]    Invalid version number: ( $version ).\e[0m\n" && usage && exit 1
}
fi

has_makefile=0
if [[ $version > $makefile_version || $version = $makefile_version ]] ; then
  has_makefile=1
fi

#If we can't find the file we may try to build it
if [[ ! -f "$script_path/$exec_entrypoint" && ! -z $version ]] ; then {
  echo -e "\n\033[1;33m[QUERY]    ( $version ) binary not found in ( $script_path ).\e[0m" #>&2
  if [[ ! $build_flag -gt 0 ]] ; then { #We exit here if we don't want to try building and we're not going to purge
    echo -e "\033[0;33m[DEBUG]    To try building, run with -b flag\e[0m\n" >&2
    [[ ! $purge_flag -gt 0 ]] && exit 1 # quit if we're not purging
  } else {
    if [[ ! -d "$script_path" ]] ; then
      echo -e "\033[1;31m[ERROR]    '$script_path' is not a valid directory.\n    Check your supported versions for details on ( $version ).\e[0m\n" >&2
      exit 1
    fi
    #we try to build
    tool_txt="single file gcc"
    if [[ $has_makefile -gt 0 ]]; then { #Make mode
      tool_txt="make"
      echo -e "\033[0;33m[MODE]    target ( $version ) >= ( $makefile_version ), has Makefile.\e[0m" >&2
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Building ( $version ), using make.\e[0m" >&2
      curr_dir=$(realpath .)
      start_t=`date +%s.%N`
      if [[ $git_mode_flag -eq 0 ]] ; then { #Building in base mode, we cd into target directory before make
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[BUILD]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
        cd $script_path; make >&2
        comp_res=$?
      } else { #Building in git mode, we checkout the tag and move the binary after the build
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;34m[BUILD]    Running in git mode, checking out ( $version ).\e[0m" #>&2
        git checkout "$version" 2>/dev/null #Repo goes back to tagged state
        checkout_res=$?
        if [[ $checkout_res -gt 0 ]] ; then { #Checkout failed, we don't build and we set comp_res
          echo -e "\033[1;31m[ERROR]    Checkout of ( $version ) failed, this stego.lock tag does not work for the repo.\e[0m" #>&2
          comp_res=1
        } else { #Checkout successful, we build
          git submodule update --init --recursive #We set all submodules to commit state
          make >&2 #Never try to build if checkout fails
          comp_res=$?
          #Output is expected to be in the main dir:
          if [[ ! -e ./$exec_entrypoint ]] ; then {
            echo -e "\033[1;31m[ERROR]    $exec_entrypoint not found at ($pwd).\e[0m" #>&2
          } else {
            mv "./$exec_entrypoint" "$script_path" #All files generated during the build should be ignored by the repo, to avoid conflict when checking out
            [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Moved $exec_entrypoint to $script_path.\e[0m" #>&2
          }
          fi
          git switch - 2>/dev/null #We get back to starting repo state
          switch_res="$?"
          [[ $switch_res -gt 0 ]] && echo -e "\n\033[1;31m[ERROR]    Can't finish checkin out ($version). Abort." && exit 1
          [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[BUILD]    Switched back to starting commit.\e[0m" >&2
        }
        fi
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
      cd "$curr_dir"
    } else { #Straight gcc mode
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[MODE]    target ( $version ) < ( $makefile_version ), single file build with gcc.\e[0m" >&2
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Building ( $version ), using gcc call.\e[0m" >&2
      #echo "" >&2 #new line for error output
      [[ -z $source_name ]] && echo -e "\n\033[1;31m[WTF-ERROR]    Missing source file name. ( $version ).\e[0m\n" && usage && exit 1

      start_t=`date +%s.%N`
      if [[ $git_mode_flag -eq 0 ]] ; then { #Building in base mode, we cd into target directory before make
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;35m[BUILD]    Running in base mode, expecting full source in $script_path.\e[0m" #>&2
        gcc "$script_path"/"$source_name" -o "$script_path"/"$exec_entrypoint" -lm 2>&2
        comp_res=$?
      } else { #Building in git mode, we checkout the tag and move the binary after the build
        [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;34m[BUILD]    Running in git mode, checking out ( $version ).\e[0m" #>&2
        git checkout "$version" 2>/dev/null #Repo goes back to tagged state
        checkout_res=$?
        if [[ $checkout_res -gt 0 ]] ; then { #Checkout failed, we set comp_res and don't build
          echo -e "\033[1;31m[ERROR]    Checkout of ( $version ) failed, stego.lock may be listing a tag name not on the repo.\e[0m"
          comp_res=1
        } else {
          git submodule update --init --recursive #We set all submodules to commit state
          gcc "./$source_name" -o "$script_path"/"$exec_entrypoint" -lm 2>&2 #Never try to build if checkout fails
          comp_res=$?
          #All files generated during the build should be ignored by the repo, to avoid conflict when checking out
          git switch - 2>/dev/null #We get back to starting repo state
          switch_res="$?"
          [[ $switch_res -gt 0 ]] && echo -e "\n\033[1;31m[ERROR]    Can't finish checkin out ($version). Abort." && exit 1
          [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[BUILD]    Switched back to starting commit.\e[0m" >&2
        }
        fi
      }
      fi
      end_t=`date +%s.%N`
      runtime=$( echo "$end_t - $start_t" | bc -l )
    }
    fi
    #Check compilation result
    if [[ $comp_res -eq 0 ]] ; then
      echo -e "\n\033[1;32m[BUILD]    Done Building ( $version ) , took $runtime seconds, using ( $tool_txt ).\e[0m"
    else
      echo -e "\n\033[1;31m[ERROR]    Build for ( $version ) failed, quitting.\e[0m\n" >&2
      exit 1
    fi

  }
  fi

} elif [[ ! -z $version ]] ; then { #Binary was present, we notify if we were running with build flag
  echo -e "\n\033[1;32m[QUERY]    ( $version ) binary is ready at ( $script_path ) .\e[0m" >&2
  [[ $build_flag -gt 0 ]] && echo -e "\033[0;33m[BUILD]    Found binary for ( $version ), won't build.\e[0m" >&2
} elif [[ ! -z $queried_version ]] ; then {
  echo -e "\033[1;31m[QUERY]    ( $queried_version ) invalid query, run with -v to see more.\e[0m"
}
fi

#We check the run flag to run the binary
if [[ ! -z $version && $run_flag -eq 1 && -x $script_path/$exec_entrypoint ]] ; then {
  echo -en "\n\033[0;32m[DEBUG]    Running script $script_path/$exec_entrypoint\e[0m"
  sleep 1
  echo -n "."
  sleep 1
  echo -n "."
  sleep 1
  echo -n "."
  sleep 1
  echo ""
  ( cd "$script_path" ; ./"$exec_entrypoint" )
} elif [[ ! -z $version && $run_flag -eq 0  ]] ; then {
  echo -e "\033[0;33m[DEBUG]    Running without -r flag, won't run.\e[0m" >&2
} elif [[ -z $version && $run_flag -gt 0 ]] ; then {
  [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[DEBUG]    Running with -r flag but couldn't find bin!\e[0m\n" >&2
}
fi

#Check if we are purging and exiting early
if [[ purge_flag -gt 0 ]]; then
  #echo "" >&2 #This newline can be redirected when doing recursion for init mode
  tot_removed=0
  for i in $(seq 0 $(($tot_vers-1)) ); do
    clean_res=1
    has_makeclean=0
    purge_vers=${supported_versions[i]}
    if [[ $purge_vers > "$makefile_version" || $purge_vers = "$makefile_version" ]] ; then
      [[ $git_mode_flag -eq 0 ]] && has_makeclean=1 #We never use make clean for purge, if in git mode
    fi
    if [[ $has_makeclean -gt 0 ]] ; then { #Running in git mode skips make clean
      tool_txt="make clean"
      has_bin=0
      curr_dir=$(realpath .)
      purge_path="$scripts_dir""v""$purge_vers"
        if [[ ! -d $purge_path ]] ; then {
          [[ $verbose_flag -gt 0 ]] && echo -e "\033[1;31m[ERROR]    '$purge_path' is not a valid directory.\n    Check your supported versions for details on ( $purge_vers ).\e[0m\n" >&2
        } else {
          [[ -x $scripts_dir/v$purge_vers/$exec_entrypoint ]] && has_bin=1 && [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[PURGE]    $purge_vers has an executable.\e[0m\n" >&2
          cd "$purge_path"; make clean 2>/dev/null 1>&2
          clean_res=$?
          cd "$curr_dir"
        }
        fi
    } else { #Doesn't have Makefile, build method 2. Running in git mode also skips using make clean
      tool_txt="rm"
      has_bin=0
      if [[ -x $scripts_dir"/v$purge_vers"/"$exec_entrypoint" ]] ; then {
        has_bin=1 && [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;32m[PURGE]    $purge_vers has an executable.\e[0m" >&2
      }
      fi
      rm $(realpath "$scripts_dir"/"v$purge_vers/$exec_entrypoint") 2>/dev/null
      clean_res=$?
    }
    fi

    #Check clean result
    if [[ $clean_res -eq 0 && $has_bin -gt 0 ]] ; then {
      #we advance the count
      tot_removed=$(($tot_removed +1))
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;33m[PURGE]    Removed ( $purge_vers ) using ( $tool_txt ).\e[0m" >&2
    } else {
      [[ $verbose_flag -gt 0 ]] && echo -e "\033[0;31m[PURGE]    Failed removing ( $purge_vers ) using ( $tool_txt ).\e[0m" >&2
    }
    fi

  done
  if [[ $tot_removed -gt 0 ]] ; then {
    echo -e "\033[0;33m[PURGE]    Purged ( $tot_removed / $tot_vers ) versions, quitting.\e[0m\n"
  } else {
    echo -e "\n\033[0;33m[PURGE]    No binaries to purge found.\e[0m\n"
  }
  fi
fi

exit 0
